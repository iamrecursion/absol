%DocumentClass
\documentclass[a4paper,11pt]{report}

%Additional Packages
\usepackage{scrextend} %for variable indentation
\usepackage{algorithm} %For algorithms
\usepackage{algpseudocode} %For algorithms
\usepackage[]{array}
\usepackage{amsmath} %Extra formula-writing functionality
\usepackage{amssymb} %More formula-writing functionality
\usepackage[toc]{appendix}
\usepackage{bm}
\usepackage{bold-extra} %Small caps
\usepackage{caption}
\usepackage{color} %Colour stuff (mostly for the highlight custom command)
\usepackage{enumerate} %For lists
\usepackage{fancyhdr}
\usepackage{float} %better float control
\usepackage[utf8]{inputenc} %for font encoding
\usepackage{framed} %For frames around blocks
\usepackage[top=2.5cm, bottom=2.5cm, left=3cm, right=3cm]{geometry} %Fix page margins
\usepackage[hidelinks]{hyperref} %For URL formleatting (makes clickable links)
\usepackage[toc, xindy, acronym, nonumberlist, nopostdot]{glossaries}
\usepackage{graphicx} %For including images, etc.
\usepackage{listings} %For including code
\usepackage{longtable} %for multi-page tables
\usepackage{mathrsfs} %For maths script fonts
\usepackage{newclude}
\usepackage{titling}
\usepackage{titlesec}
\usepackage[nottoc]{tocbibind}
\usepackage[]{natbib} %For the bibliography
%\usepackage[superscript]{cite}
\usepackage{pdfpages} %For including PDFs
\usepackage[]{pdflscape}
\usepackage{stmaryrd}
\usepackage{subcaption}
\usepackage{tabu} %more pretty tables
\usepackage{tabulary} %for nice tables
\usepackage{tabularx} %also for nice tables
\usepackage{ulem}
\usepackage{xcolor}
\usepackage{xparse}
\usepackage{textcomp}
\usepackage[prefix=sol-]{xcolor-solarized}

\usepackage{relsize}

%CustomCommands
\newcommand{\highlight}[1]{\colorbox{yellow}{#1}} %Highlights text
\newcommand{\limplies}{\to} %Creates the logical implication sign
\newcommand{\liff}{\leftrightarrow} %Creates the double logical implication sign
\newcommand{\leftabs}{\left\lvert} %Left absolute value bracket
\newcommand{\rightabs}{\right\rvert} %Right absolute value bracket
\newcommand{\textbsc}[1]{\textsc{\textbf{#1}}}
%\renewcommand\thesubsection{(\alph{subsection})} %Make subsections alphabetical
\newcommand{\id}{\hspace*{12pt}}
\newcommand{\newpar}{\vspace{12pt}}
\newcommand{\lam}{$\lambda$}
\newcommand{\alp}{$\alpha$}
\newcommand{\bet}{$\beta$}
\newcommand{\aequiv}{=_\alpha}
\newcommand{\bequiv}{=_\beta}
\newcommand{\bconv}{\limplies_\beta}
\newcommand{\context}{$\Gamma$}
\newcommand{\rspace}{\;\;\;\;\;\;\;\;}
\newcommand{\eval}{\Downarrow}

% New Table Column Types
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

% Syntax: \newdualentry[glossary options][acronym options]{label}{abbrv}{long}{description}
\DeclareDocumentCommand{\newdualentry}{ O{} O{} m m m m } {
    \newglossaryentry{gls-#3}{name={#5},text={#5\glsadd{#3}},
        description={#6},#1
    }
    % \makeglossaries
    \newacronym[first=#5, firstplural=#5s, see={[Glossary:]{gls-#3}},#2]{#3}{#4}{#5 \glsseeformat[Glossary:]{gls-#3}{#5}\glsadd{gls-#3}}
    % \newacronym[see={[Glossary:]{gls-#3}},#2]{#3}{#4}{#5\glsadd{gls-#3}}
}

% For quoting \quoteit{quote}{attribution}
\newcommand{\quoteit}[2]{
    \begin{longtable}{p{14cm}}
        \textit{``#1''} \\
        % \hspace{5mm} --- #2 
        \begin{tabular}{R{14cm}}
            --- #2
        \end{tabular}
    \end{longtable}
}

% For definitions \defblock{colsize}{name}{description}
\newcommand{\defblock}[3]{
    \begin{longtable}{l p{#1}} 
        \textbf{#2} & #3
    \end{longtable}
}

%Various Definitions
\setcounter{tocdepth}{2}
\definecolor{light-gray}{gray}{0.5}

\titleformat{\chapter}
    {\normalfont\huge}  % format
    {\thechapter.}      % label
    {10pt}              % separation
    {\huge\it}          % before-code

\pagestyle{fancy}
\lhead{\color{light-gray}Ara Adkins}
\rhead{\color{light-gray}Project Proposal}
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

\setlength{\parindent}{0pt}
\setlength{\headheight}{14pt}

\hypersetup{
    colorlinks,
    linkcolor={blue!30!black},
    citecolor={blue!30!black},
    urlcolor={blue!80!black}
}

\makeatletter
\renewcommand\@dotsep{200}
\makeatother

\renewcommand{\labelenumii}{\theenumii}
\renewcommand{\theenumii}{\theenumi.\arabic{enumii}.}

% Listings Styles
\lstset{
    % How/what to match
    sensitive=true,
    % Border (above and below)
    frame=lines,
    % Extra margin on line (align with paragraph)
    xleftmargin=0.5cm,
    % Put extra space under caption
    belowcaptionskip=1\baselineskip,
    % Colors
    backgroundcolor=\color{sol-base3},
    basicstyle=\color{sol-base0}\ttfamily,
    keywordstyle=\color{sol-cyan},
    commentstyle=\color{sol-base01},
    stringstyle=\color{sol-blue},
    numberstyle=\color{sol-violet},
    identifierstyle=\color{sol-base00},
    % Break long lines into multiple lines?
    breaklines=true,
    % Show a character for spaces?
    showstringspaces=false,
    tabsize=4,
    numbers=left,
    numbersep=5pt,
    numberstyle=\tiny\color{sol-base1},
    rulecolor=\color{sol-base01},
    aboveskip=2em,
    belowskip=2em,
    upquote=true
}

% Title
% \pretitle{
% 	\begin{center}
% }
% \posttitle{
%     \end{center}
% }

\title{ABSOL: Specification and Formal Verification of Domain-Specific Languages through Automatic Compiler Generation in Haskell}
\author{Ara Adkins}
\date{\today}

% Glossaries
\makeglossaries
\include{resources/glossary}
\glsaddall % add ell items to the glossaries}

%Document
\begin{document}

\maketitle

\tableofcontents

\printglossaries

% - A detailed description and exploration of the problem that the project is seeking to address (2-3 pages + references)
% - Expand upon and modify the initial project idea in order to suit the student's knowledge and understanding. Deep understanding of the project to be attempted, clearly drawing on information from the sources. 
% - Should show evidence of additional reading and identification of background reading sources, with evidence that the background reading has clearly shaped the proposal.
% - Clear appreciation for other areas of knowledge that may be brought to bear on the project
% - Appreciations for the completion of the project on the users and / or research community.
% - External references and sources are appropriately cited and used, no use of inappropriate sources.
\chapter{Problem Description} % (fold)
\label{cha:problem_description}
This project aims to create a framework and toolchain for the formal verification of embedded, executable Domain-Specific Languages.
The hope is to allow the generation of provably correct, tailored programming languages that can encapsulate domain logic inside another program.
These languages will be compiled through the use of a Haskell metacompiler (a compiler that generates a compiler) that takes both syntax and semantics for the Domain-Specific Language, generating executable libraries for embedding the DSL.

\section{An Introduction to Domain-Specific Languages} % (fold)
\label{sec:an_introduction_to_domain_specific_languages}
Modern software systems are increasing in complexity, with everything from flight computers to business software growing \citep{dvorak2009nasa}.
As these systems grow, the domain logic is becoming integrated throughout the systems, leading to increased levels of coupling throughout the code.
This means that there is an increased risk that changes to the software create modes of incorrect operation \citep{khawar2001developing}.\\

In reaction to the dispersion of domain logic throughout modern software systems, Domain-Specific Languages (DSLs) have seen ``a significant uptick in interest'' \citep{fowler2010domain}. 
A DSL is a limited, application-specific language that is integrated with another software system, providing a custom encoding of domain rules and logic that can often go beyond the syntactic constraints of the host language \citep{Mernik:2005:DDL:1118890.1118892}.
In the use of a DSL, software systems are able to centralise their domain logic using a common syntax, making it simple to change rules for the operation of the program.\\

The term `Domain-Specific Language' is a broad one, encompassing a variety of embedded syntaxes for defining domain logic.
Fowler defines `internal' and `external' DSLs.
An internal DSL is written in the host language and exposed via an API, also known as a fluent interface.
\cite{fowler2010domain} defines an external DSL, in contrast, as a language parsed independently of the host language.\\

In addition to their structure, Domain-Specific Languages can also be defined in terms of their `executability' \citep{Mernik:2005:DDL:1118890.1118892}.
Many DSLs are programming languages with `well-defined execution semantics'.
Examples of this are \LaTeX, a macro language for \TeX, and Template Haskell, which allows manipulation of Haskell code itself using Haskell \citep{sheard2002template}.
As a counterpoint, some DSLs only define configuration information for a software system, having no executable semantics of their own.

% section an_introduction_to_domain_specific_languages (end)

\section{The Need for Correct DSLs} % (fold)
\label{sec:the_need_for_correct_dsls}
Initial inspiration for this project was engendered by the observation of a financial technology company using the general-purpose programming language OCaml for specifying logic at runtime.
As a Turing-complete programming language, this offered vastly greater expressive power than necessary for the domain in which it was applied.
This meant an increase in the potential for bugs in the domain logic, as suggested by \cite{subramanyam2003empirical}.
If a capable DSL could be designed that could have formally verified properties, then it would be a much better fit to the domain while reducing the capacity for bugs.\\

While the scope of common DSLs is necessarily very broad, encompassing everything from executable program logic to statically defined configuration, this project aims to focus on a small subset of DSLs.
As formal correctness only applies to executable programs, this project will focus on external, executable DSLs. 
While analysis could benefit internal DSLs as well, they are already covered by traditional code review mechanisms, and would be hard to integrate into this project.\\

Even with the ``detailed analysis and structuring of the application domain'' \citep{van2000domain} performed when initially defining the DSL, it can be difficult to verify the correctness of the resulting language. 
While current methods can utilise code-review to attempt to analyse the correctness of the DSL implementation, a lack of understanding of the domain by the application developers may cause logic errors to be missed. 
This is because the domain logic is often embodied by expert knowledge, as found by \cite{studer1998knowledge}. 
It can hence be difficult to verify the language implementation with those domain experts, through code-review, due to their lack of understanding of the implementing language.
As core domain logic, often integral to the program, is encapsulated by the DSL, it is instrumental that it be formally correct.\\

This project aims to provide a solution for the sixth step of DSL design as proposed by \cite{van2000domain}: ``design and implement a compiler that translates DSL programs''. 
While the logic that the DSL aims to encode can be verified with domain experts, it is often difficult to verify the resulting implementation.
As the language semantics are integral to the operation of the DSL, providing the semantic analysis and verification as part of the toolchain will allow the automatic generation of DSLs.
The generation from specification greatly reduces the potential for errors introduced during the implementation.
An automated system offers benefits over manual review, as the domain experts can work with the DSL designers to encode the correct semantics before it becomes an executable program.

% section the_need_for_correct_dsls (end)

\section{Verification of DSL Semantics} % (fold)
\label{sec:verification_of_dsl_semantics}
While it would be desirable to design a system for verification of arbitrary DSL semantics, there are certain classes of problem in semantic verification which are not decidable \citep{abdulla1994undecidable}. \\

This is most elegantly expressed in the duality of data and codata, or recursion and corecursion. 
While recursively defined structures are decomposed from a state into certain `base-cases', providing a well-defined termination property, corecursion aims to start from a `base-case' and build data from there \citep{hinze2010reasoning}.
As corecursion is dual to recursion, codata is the potentially infinite dual to data, which is necessarily finite. \\

If the program semantics are limited to those that can be defined recursively rather than corecursively; that is, via structural induction rather than coinduction, then termination can be proven for such programs \citep{nordstrom1988terminating}.\\

In the limited domain of recursively defined program semantics, this project aims to build on the work of \cite{doh2001composing}, drawing on the \textit{PlanCompS} project for specifying modular programming language semantics.
It will also draw upon the work of Godel's `System-T', a theory of arithmetic for finite types that allows reasoning about arbitrarily-sized, finite data structures via structural induction \cite{girard1989proofs,alves2010godel}.\\

The aim is to define a set of what Mosses terms `funcons' (\textit{fundamental constructs}); a set of semantic building blocks that can all be proven to terminate \cite{churchill2014reusable}.
Alongside a metalanguage that is able to specify both syntax and semantics for the DSL, the project aims to create a toolchain for verifying the DSL semantics and producing an executable library for the DSL.\\

Using the metalanguage definition of the syntax and semantics for the DSL, the project toolchain will act as a metacompiler \cite{Mandell:1966:MDA:800267.810785}.
This means it will produce an executable for the DSL via metacompilation and compilation steps.
The provided semantics will allow decomposition, through structural induction, into the funcons, allowing the termination properties to be proved.
The funcons and associated program code can then be composed to generate the program that matches the semantics defined for the DSL.\\

% section verification_of_dsl_semantics (end)

\section{The Novel Contribution of this Project} % (fold)
\label{sec:the_novel_contribution_of_this_project}
This project aims to make a novel research contribution through the creation of two main components:
\begin{itemize}
    \item \textbf{A DSL Metalanguage:} A metalanguage for the specification of the syntax of a DSL, along with its associated semantics. 
    The syntactic notation will likely be based upon the Extended Backus-Naur Form, a metasyntax notation for expressing languages whose syntax matches a context-free grammar. 
    The corresponding semantic notations will likely be based on the conventional big-step operational semantics \citep{Schmidt:2003:PLS:1074100.1074733} devised for automatic compiler generation \citep{diehl1996semantics}.
    \item \textbf{A Metacompiler:} This metacompiler program will take a DSL description in the above metalanguage, and a program in the described DSL, and produce a working executable from this. 
    This may operate in a single-step or multipass process, depending on what makes for the most simple metacompiler architecture.
\end{itemize}

Through limiting scope to just recursively defined semantic constructs, and omitting consideration of corecursive constructs, this project will be able to produce a useful metacompiler for a set of language semantics within which arbitrary DSLs can be constructed. 

% section the_novel_contribution_of_this_project (end)

\section{Project Objectives} % (fold)
\label{sec:project_objectives}
The main objectives of this project are as follows:
\begin{itemize}
    \item Conduct research on methods for the syntactic description of fundamental program syntax and semantics.
    \item Use the knowledge gained from this research to develop the \textit{Absol}\footnote{Automatic Builder for Semantically Organised Languages: The name of the metacompiler toolchain} metalanguage to describe the syntax and semantics of an arbitrary domain-specific language.
    \item Define a set of basic \textit{funcons} as fundamental building blocks for programs with purely recursively defined semantics. 
    These building blocks will have trivially true termination properties.
    \item Describe methods for semantic decomposition, allowing the program semantics specified using \textit{Absol} to be decomposed to the \textit{funcons}, allowing termination proof for the semantics via structural induction (they are all total functions, and compositions of total functions are also total).
    Structurally recursive semantic definitions allow us to decompose the semantics to the \textit{funcons}, as long as we can express all DSL semantics in terms of these building blocks. 
    \item Development of a basic DSL using the metalanguage.
    \item Development of a minimum working example for the metacompiler using hand-implemented semantics based on the \textit{Absol} metalanguage.
    \item Development of a working metacompiler that can ingest a description of the DSL's syntax and semantics using \textit{Absol}, as well as a program in the DSL itself, and produce a working executable program.
    \item Creation of a more-capable and useful DSL with additional capabilities (as outlined in Section~\ref{sub:extended_dsl}).
    \item Evaluate the metacompiler in terms of real-world utility and theoretical contribution based on the requirements and the theoretical and practical impact in relation to the literature surveyed.
\end{itemize}


% section project_objectives (end)

% chapter problem_description (end)

% =============================================================================

% - A high-level requirements specification identifying the main deliverables and objectives for the project (1-3 pages)
% - Requirements attempt to bound the project rigorously, including scope constraints.
\chapter{Requirements Specification} % (fold)
\label{cha:requirements_specification}
This section outlines the high-level requirements for the project.

\section{Functional DSL} % (fold)
\label{sec:functional_dsl}
The DSL that will be devised for the project will be developed in two phases.
The initial phase involves a very simple language that is capable of basic operations and data traversal, and is intended to be used for the hand-implemented metacompiler proof-of-concept.
The more advanced phase brings additional language features if time permits, integrating them into the language to test the capabilities of the metacompiler.

\subsubsection{Simple DSL} % (fold)
\label{ssub:simple_dsl}
The basic DSL has a set of functional and non-functional requirements.

\subsubsection{Functional Requirements} % (fold)
\label{ssub:functional_requirements_simple}
The basic DSL \textit{will} provide:
\begin{itemize}
    \item Simple data types (integers, floating-point numbers, strings), with operations defined on those data types.
    \item An error-handling mechanism
    \item Functions that can take arguments and return a tuple of result and error state. 
    These can be defined by the users.
    \item A single collection data type, allowing arbitrary-length data.
    \item \lstinline{map(fn, data)}, an operation that allows traversal of data structures.
\end{itemize}

% subsubsection functional_requirements (end)

\subsubsection{Non-Functional Requirements} % (fold)
\label{ssub:non_functional_requirements_simple}
The basic DSL \textit{will} fulfil the following requirements:
\begin{itemize}
    \item A statically typed type system.
    \item The DSL will be purely functional, with all functions defined to be pure, total functions.
\end{itemize}

% subsubsection non_functional_requirements (end)

% subsubsection simple_dsl (end)

\subsection{Extended DSL} % (fold)
\label{sub:extended_dsl}
The extended DSL has all of the requirements of the simple DSL (Section~\ref{ssub:simple_dsl}), and the following.

\subsubsection{Functional Requirements} % (fold)
\label{ssub:functional_requirements_extended}
On top of the functionality defined for the basic DSL, the extended DSL \textit{will} provide:
\begin{itemize}
    \item Higher-order functional constructs, allowing functions to be first-class types in the language, and be passed as arguments.
    \item User-definable data-types (e.g. ADTs)
\end{itemize}

% subsubsection functional_requirements (end)

\subsubsection{Non-Functional Requirements} % (fold)
\label{ssub:non_functional_requirements_extended}
If time permits, the extended DSL \textit{may} also provide:
\begin{itemize}
    \item Type-inference functionality utilising the Haskell type-inference engine (Hindley-Milner Type Inference).
    \item State propagation via an extension of the error mechanism.
\end{itemize}

% subsubsection non_functional_requirements (end)

% subsection extended_dsl (end)

% section functional_dsl (end)

\section{DSL Metalanguage --- Absol} % (fold)
\label{sec:dsl_metalanguage_absol}
The metalanguage has the following requirements.

\subsection{Metalanguage: Functional Requirements} % (fold)
\label{sub:metalanguage_functional_requirements}
The metalanguage \textit{will} satisfy the following requirements:
\begin{itemize}
    \item Provide a syntax capable of specifying both the syntax and semantics of the DSL being expressed.
    \item Provide a set of funcons; building blocks from which the computational semantics of the DSL can be composed. 
    \item Have provable termination properties for these funcons (i.e. the funcons should be total functions and compositions of total functions are total).
\end{itemize}

% subsection metalanguage_functional_requirements (end)

\subsection{Metalanguage: Non-Functional Requirements} % (fold)
\label{sub:metalanguage_non_functional_requirements}
The metalanguage \textit{may} satisfy the following requirements:
\begin{itemize}
    \item The syntax should be as natural as possible.
    \item The syntax should be intuitive where possible, drawing on existing concepts for specifying both syntax (e.g. EBNF) and semantics (e.g. big-step operational semantics).
    \item The language may be more general than the specific application for which it is being developed.
\end{itemize}

% subsection metalanguage_non_functional_requirements (end)

% section dsl_metalanguage_absol (end)

\section{DSL Metacompiler} % (fold)
\label{sec:dsl_metacompiler}
The DSL metacompiler will satisfy the following requirements.

\subsection{Metacompiler: Functional Requirements} % (fold)
\label{sub:metacompiler_functional_requirements}
The metacompiler \textit{will}:
\begin{itemize}
    \item Take both a metalanguage specification and DSL source file as input.
    \item Provide a mechanism to parse the syntax specified in the metalanguage input file.
    \item Provide a mechanism to parse the semantics specified in the metalanguage input file and decompose these into funcons.
    \item Build the program semantics for the input source file using these funcons.
    \item Output a Haskell module containing executable code for the DSL that can then be compiled using GHC for use with a Haskell program or other program that provides a C-like foreign-function interface (FFI).
    \item Alternatively, the metacompiler process may generate a compiler for the DSL in question, requiring a two-step process to generate the Haskell module as output. 
\end{itemize}

% subsection metacompiler_functional_requirements (end)

\subsection{Metacompiler: Non-Functional Requirements} % (fold)
\label{sub:metacompiler_non_functional_requirements}
The metacompiler \textit{will}:
\begin{itemize}
    \item Be built using a sensible, modular design.
    \item Be designed with extensibility in mind.
\end{itemize}

% subsection metacompiler_non_functional_requirements (end)
% section dsl_metacompiler (end)

\section{Project Scope} % (fold)
\label{sec:project_scope}
This project is operating in an area of active research and so the scope has been intentionally constrained.
Through constraining the scope of this project it is hoped that a meaningful contribution can be made. 
The following factors act to constrain project scope:
\begin{itemize}
    \item \textbf{Static Typing:} Dealing with dynamic typing would impose significant constraints on the design of the metacompiler, adding additional complexity to its operation.
    Ensuring this worked correctly would likely take more time than is available for the project.
    \item \textbf{No Codata:} While general-purpose programming languages have the ability to deal with codata and infinite data structures (e.g. streams, I/O), this project will omit this ability.
    This is for two reasons:
    \begin{enumerate}
        \item It is unlikely to be useful for DSLs, as the DSL components can be called from the general-purpose programming language in which it is embedded.
        \item Termination properties cannot be proved for codata, meaning that not all programs in DSLs could be proved to be correct.
    \end{enumerate}
    \item \textbf{Performance:} The project is not aiming to target performance and optimisation for the metacompiling process or the generated code itself beyond what is afforded by GHCs optimising compiler (as the target language is Haskell).
    \item \textbf{No Consideration of Turing-Complete Programming Languages:} The project does not aim to consider turing-complete programming languages as part of its scope, mainly because codata is required to be turing complete.
    \item \textbf{No Linguistic State:} In the default project requirements there is no need to work with state. 
    State poses some interesting issues working with pure functions and functions that may have side-effects, so this is being ruled out of scope for the project.
\end{itemize}

% section project_scope (end)

% chapter requirements_specification (end)

% =============================================================================

% - A *detailed* project plan using appropriate techniques (e.g. Gantt Chart) that identifies the tasks you will undertake and the initial time allocation on these tasks
% - Project plan identifies major steps and decomposes these appropriately.
\chapter{Project Plan} % (fold)
\label{cha:project_plan}
This project plan aims to describe the intended progress of the project, including any planned contingencies.
It highlights the major phases of the project, and also the major project milestones.\\

The project plan assumes approximately 15 hours a week is spent on the project. 
This will allow time to accommodate other coursework, as well as time for contingencies should things not go according to plan.\\

The plan incorporated explicit contingencies, finishing the relevant stages ahead of any deadlines, ensuring that there will be something to hand in even if the task is not at the intended stage by the deadline.
Each stage has the unwritten assumption that it includes time for additional research and note-taking where necessary.\\

The gantt chart for the project plan can be found in Appendix~\ref{cha:project_plan_gantt_chart} on page~\pageref{cha:project_plan_gantt_chart}.

% chapter project_plan (end)

% =============================================================================

% - A list of resources required to complete the project along with their availabilities.
\chapter{Resources} % (fold)
\label{cha:resources}
Due to the highly theoretical nature of this project, it requires little in terms of software resources, and no physical equipment resources for project completion.

\section{Software Resources} % (fold)
\label{sec:software_resources}
The major software resources required for the completion of this project are:
\begin{itemize}
    \item \textbf{The Glasgow Haskell Compiler:} GHC is the most advanced Haskell compiler currently available, providing multiple extensions on the Haskell language that will be invaluable in the project.
    The metaprogramming facilities devised by \cite{sheard2002template} will be valuable in the implementation of the metacompiler. 
    \item \textbf{The Parsec Parsing Library:} Parsec is an industrial-strength, monadic, parser combinator library with the ability to parse languages with grammars as complex as Context-Sensitive and Infinite-Lookahead.
    Parsec will be used to simplify the parsing routines for both the syntax and semantics specified by the \textit{Absol} metalanguage.
    \item \textbf{Stack:} A modern build tool for Haskell, providing totally reproducible builds. 
    It also supports regular unit testing and comprehensive release management.
    \item \textbf{Sublime Text 3:} A modern, extensible text editor with excellent performance characteristics and a flexible plugin architecture.
    It will be used for working on the code portions of the project.
    \item \textbf{SublimeHaskell Haskell Toolchain:} A Sublime Text plugin to support writing complex Haskell projects. 
    It provides semantic completion, refactoring support, linting, syntax styling and full type-inference (type signature completion), as well as integrating Haskell build tools with Sublime Text.
\end{itemize}

% section software_resources (end)

\section{Personnel Resources} % (fold)
\label{sec:personnel_resources}
While the project should be able to proceed without close support of personnel, it will be useful to have access to:
\begin{itemize}
    \item \textbf{Prof. Guy McCusker (Project Supervisor):} The project is highly theoretical, and there is the potential for a few instances where theoretical concepts found in various resources will require additional explanation or clarification.
    \item \textbf{Prof. Peter Mosses (Swansea):} This project builds heavily upon his work with \textit{PlanCompS}, and it may be useful to be in communication with him to discuss ideas and request clarification on his work where necessary.
\end{itemize}

% section personnel_resources (end)

% chapter resources (end)

% BIBLIOGRAPHY
\bibliographystyle{abbrvnat}
\bibliography{resources/bibliography}

\begin{appendix}
    
\chapter{Project Plan: Gantt Chart} % (fold)
\label{cha:project_plan_gantt_chart}
This appendix contains the detailed Gantt chart project plan for this project.

\includepdf[pages={-}, landscape]{resources/absol_final_year_project_plan.pdf}

% chapter project_plan_gantt_chart (end)

\end{appendix}

\end{document}
