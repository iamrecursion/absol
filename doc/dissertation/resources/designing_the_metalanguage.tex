\chapter{Designing the Metalanguage} % (fold)
\label{cha:designing_the_metalanguage}
As a project, \gls{absol} has had a very heavy research bent. 
The experimental nature of the toolchain resulted in significant up-front design work and, combined with the highly theoretical nature of the language verification algorithms, this meant that language design and algorithmic development dominated the time spent on the project.
This section aims to illustrate the comprehensive design work that was put into the first of the two main project components: the metalanguage --- \gls{metaspec}. \\

\gls{metaspec} is the metalanguage for the \gls{absol} project, allowing the language designers to specify both the syntax and semantics of their DSL, as well as associated metadata, in a unified form. 
The final syntax for Metaspec is the result of significant design work, and consequentially the syntax discussed below has been through some evolution. \\

Metaspec is, in itself, a \gls{dsl}, and hence its design process was an interesting insight into how people might use the language to design their own \glspl{dsl}. 
The complete grammar for Metaspec can be found in Appendix~\ref{cha:the_metaspec_grammar}, and is written in standard \gls{ebnf} notation. 
The same notation will be used throughout this section of the document when referring to the metaspec grammar itself.

\section{The Top-Level Definitions} % (fold)
\label{sec:the_top_level_definitions}
The top-level structure of a Metaspec file consists of a series of ordered top-level definitions.
The presence of these definitions emerged from the seemingly disparate nature of a number of the requirements placed upon the language.
They are as follows:
\begin{enumerate}
    \item The language name (Requirement~\reqref{req:LanguageMetadata})
    \item The language version (Requirement~\reqref{req:LanguageMetadata})
    \item Language feature imports (Requirement~\reqref{req:ExtensionMechanisms})
    \item Ground truths for the proof engine (Requirement~\reqref{req:Ground-TruthSemantics})
    \item The language itself (Requirement~\reqref{req:IntegratedSyntaxandSemanticSpecification})
\end{enumerate}

Tying these somewhat disparate areas together is the requirement for language definition files to read in an ``intuitive'' fashion (Requirement~\reqref{req:IntuitiveFileStructure}). 
This provided an initial sense for the ordering of the language definitions, as each block assisted in providing the contextual foundation for the language definition itself. \\

To this end, the decision was made to enforce the ordering of these in the language grammar itself (as seen in Listing~\ref{lst:top_level_metaspec_definition_blocks}), with the ordering as above.

\begin{listing}[!htb]
\begin{minted}[firstnumber=156]{text}
metaspec-defblock = 
    name-defblock, rule-termination-symbol, 
    version-defblock, rule-termination-symbol, 
    using-defblock, rule-termination-symbol, 
    truths-defblock, rule-termination-symbol, 
    language-defblock, rule-termination-symbol;
\end{minted}
\caption{Top-Level Metaspec Definition Blocks}
\label{lst:top_level_metaspec_definition_blocks}
\end{listing}

Placing the metadata fields first was a natural way to provide some initial context as to the language and version, and also assists with at-a-glance checking the language version in a \gls{vcs}.
As the extensions import list, the \mintinline{text}{using-defblock}, can contain dependencies of the final two blocks, it made a significant amount of sense to put this next, as it aids in establishing context for the following blocks.\\

The ordering of the termination truths (\mintinline{text}{truths-defblock}) and the language definition itself (\mintinline{text}{language-defblock}) was similarly natural. 
While the truths are mainly depended upon by the termination proof mechanism (see \autoref{sub:metaverify_the_verification_engine}), they can also act as a guide to the language designer to indicate where they will be required to provide semantics for a language production. 
This quite clearly indicates that the termination truths should come before the language definition itself, as they provide additional context for the language designer.\\

While one might argue for the separation of these top-level elements, particularly the metadata, into multiple files, it seems far more natural to combine them all under one umbrella.
This means that each language definition is a self-contained unit with all the context required to understand it. 
While this single-file requirement does mean that definitions for large DSL could become unwieldy, taking a single-file approach significantly simplifies the metacompiler implementation.\\

Each of these top-level blocks have fairly distinct forms, and each was designed very carefully to aid the language designer's understanding of the file.
While it is not worth dwelling on their design, the most important design decisions should be noted.
\begin{itemize}
    \item \textbf{The Metadata Blocks:} While seemingly simplistic, the definitions of both the language name and version definition blocks was intended to not enforce any name or version scheme as \citet{raemaekers2014semantic} found the semantics of these to vary drastically between projects.
    As a result, both fields are utf-8 strings, parsed from the first non-whitespace character to the last occurring before the rule termination symbol (\mintinline{text}{;}), as seen in \autoref{lst:metadata_block_definitions}.
\begin{listing}[!htb]
\begin{minted}[xleftmargin=1cm, firstnumber=156]{text}
name-defblock = "name", where-symbol, { utf-8-char }-,;
version-defblock = "version", where-symbol, { utf-8-char }-,;
\end{minted}
\caption{Metadata Block Definitions}
\label{lst:metadata_block_definitions}
\end{listing}

    \item \textbf{The Imports Definition Block:} While the one-line-per-import style (oft used in programming languages) was considered due to its syntactic flexibility (allowing statements that modify the import --- e.g. \mintinline{haskell}{import qualified Data.Maybe as M}), a comma-separated list was chosen. 
    This is both more in-keeping with the style of metaspec as a language, and better accommodates the simple-keyword imports of the language. 
    It is hence defined as shown in \autoref{lst:the_using_definition_block}. 
\begin{listing}[!htb]
\begin{minted}[xleftmargin=1cm, firstnumber=175, escapeinside=||]{text}
using-defblock =
    "using",
    where-symbol,
    semantic-block-start,
    [ metaspec-feature, 
        { semantic-list-delimiter, metaspec-feature }]
    semantic-block-end; 
\end{minted}
\caption{The Using Definition Block}
\label{lst:the_using_definition_block}
\end{listing}

    \item \textbf{The Language Truths Block:} Understanding a language defined in Metaspec relies on the understanding of the trivial `base-cases' that are assumed to terminate by the proof engine. 
    The semantics of each truth can be understood as meaning ``this evaluation always terminates''.
    While it was initially thought that these could be generated automatically, doing so would have removed significant language flexibility, as much of said flexibility comes from the users specifying semantics exactly as they require. 
    To this end, users specify the termination cases for all symbols, even those they did not define.
    The format for doing so is taken almost directly from the language semantics (see \autoref{sec:specifying_the_language_semantics}) to allow for easy visual identification during language design, as can be seen in \autoref{lst:the_truths_definition_block}.
\begin{listing}[!htb]
\begin{minted}[xleftmargin=1cm, firstnumber=182]{text}
truths-defblock =
    "truths",
    where-symbol, 
    semantic-block-start,
    semantic-evaluation,
    { ", ", semantic-evaluation },
    semantic-block-end;
\end{minted}
\caption{The Truths Definition Block}
\label{lst:the_truths_definition_block}
\end{listing}

    \item \textbf{The Language Definition Block:} This block has a very simple design, acting as nothing but a container for the productions of the language, as seen in \autoref{lst:the_language_definition_block}.
    The form of these productions is discussed in ections~\ref{sec:specifying_the_language_syntax} and~\ref{sec:specifying_the_language_semantics}, and is the result of combining the two as discussed in Section~\ref{sec:combining_syntax_and_semantics}.
\begin{listing}[!htb]
\begin{minted}[xleftmargin=1cm, firstnumber=191]{text}
language-defblock =
    "language",
    where-symbol,
    semantic-block-start,
    language-definition,
    semantic-block-end;
\end{minted}
\caption{The Language Definition Block}
\label{lst:the_language_definition_block}
\end{listing}

    \item \textbf{Comments in Metaspec:} With comments being crucial in any programming or specification language, it was important to determine how they would look in Metaspec. 
    Requirement~\reqref{req:Comments} states that comments need not have any semantic meaning (contrasted with Python Docstrings, which are compiled with their functions \citep{python_docstrings}), and could hence be very simple and removed during preprocessing. 
    The choice of the comment symbols was informed by \gls{ebnf} for the block-comment style (using \mintinline{text}{"(*"} and \mintinline{text}{"*)"}), while the line-comment style was derived from the common C-style operator (\mintinline{text}{"//"}).
    Comments are thus defined as in \autoref{lst:comments_in_metaspec} below.
\begin{listing}[!htb]
\begin{minted}[xleftmargin=1cm, firstnumber=149]{text}
metaspec-comment =
    line-comment-start-symbol, { utf-8-char }, eol-symbol |
    block-comment-start-symbol, { utf-8-char }, 
        block-comment-end-symbol;
\end{minted}
\caption{Comments in Metaspec}
\label{lst:comments_in_metaspec}
\end{listing}
\end{itemize}

% section the_top_level_definitions (end)

\section{Specifying the Language Syntax} % (fold)
\label{sec:specifying_the_language_syntax}
Metaspec, as a hybrid metalanguage, needed to have the ability to specify the syntax of the language it describes. 
As discussed in \autoref{sub:choosing_a_syntactic_form}, the predominant notation for specifying language syntax that is used today is \gls{ebnf}.
Metaspec adapts the \gls{ebnf} syntactic specification language, taking the set of definitions for specifying productions almost directly.
This decision was made for a few main reasons:
\begin{itemize}
    \item \textbf{Flexibility of Syntactic Definition:} \gls{ebnf} is already capable of representing both context-free and context-sensitive language grammars.
    Furthermore, \gls{ebnf} places \textit{no restriction} on the format of the terminals of the language, which is important for allowing \glspl{dsl} to get as close to the domain notation as possible. 
    Any form of syntactic specification that would be devised as part of this project would likely be flawed in some way, shape or form, or not be as flexible as the extant notation in the form of \gls{ebnf}. 
    \item \textbf{User Familiarity:} Due to the prevalent use of \gls{ebnf} in the programming language community and its standardised nature, it was felt that providing a syntactic notation that the users would be familiar with would ease use of Metaspec. 
    \item \textbf{Correctness:} Adaptation of a pre-defined and well-studied metasyntax notation is far less likely to result in errors than implementing a new notation from scratch.
\end{itemize}

That is not to suggest, however, that the \gls{ebnf} productions were taken entirely as-is. 
As part of adapting the long-standing metasyntactic notation, there were a few changes made to its syntax.
These changes were in aid of providing better operation with other portions of the toolchain, as well as fixing some of the less-intuitive elements of the \gls{ebnf} grammar. 

\subsection{Adapting the Form of Non-Terminals} % (fold)
\label{sub:adapting_the_form_of_non_terminals}
Standard \gls{ebnf} represents non-terminals by strings of textual characters, including spaces.
This means that they can be difficult to visually identify for the reader of the grammar, and that concatenation of terminals and non-terminals is defined by the inelegant operator (\mintinline{text}{,}).
Metaspec adapts this through explicitly delimiting the non-terminals, as shown in \autoref{lst:non_terminals_in_metaspec}.

\begin{listing}[!htb]
\begin{minted}[numbers=none, fontsize=\blockfont]{text}
non-terminal-start = "<";
non-terminal-end = ">";
non-terminal-identifier = 
    textual-glyph, { textual-glyph | natural-number | "-" | "_"};
non-terminal = non-terminal-start, non-terminal-identifier, non-terminal-end;
\end{minted}
\caption{Non-Terminals in Metaspec}
\label{lst:non_terminals_in_metaspec}
\end{listing}

The use of the distinctive angle brackets both helps to visually distinguish the non-terminals of the language, and syntactically delimit the non-terminals.
As a result, there is no need for an explicit concatenation operator, reducing visual noise in the Metaspec definitions.\\

This altered syntax for non-terminals also brings benefits when it comes to parsing the semantics. 
The semantics of a language defined in metaspec may contain variable identifiers (as discussed in \autoref{sub:user_defined_semantics}), but also require access to elements of the syntax (see \autoref{sub:accessing_syntax_from_the_semantics}).
These identifiers look much like standard \gls{ebnf} non-terminal names, and so the alterations made for \gls{metaspec} provide some additional ability to disambiguate at the parser level. 

% subsection adapting_the_form_of_non_terminals (end)

\subsection{Specification of the Language Start Rule} % (fold)
\label{sub:specification_of_the_language_start_rule}
One of the things that \gls{ebnf} lacks is an explicit method of representing the `start rule' of a grammar. 
The start rule (or start symbol) in any grammar is the place from which a parse either \textit{starts}, or where a parse will \textit{end} \citep{slonneger1995formal}.
For automated tools working with syntax, this is clearly important to define. \\

Beyond the requirement to use the grammar portion of the specification for parser generation, the notion of a start symbol is also useful when it comes to verifying the language semantics.
The start symbol can act as the point from which the verification starts, and thus brings the ability to check for other criteria on the language (unused productions, syntax-only productions, etc). \\

While it could be simple as to provide a metadata field specifying the name of the start symbol for the \gls{dsl}, that seemed inelegant. 
Instead, a special type of non-terminal declaration was added; where non-terminals are enclosed in angle brackets --- \mintinline{text}{<nt>} --- the start symbol is enclosed in a set of double angle brackets: \mintinline{text}{<<start>>}. 
This means that it can be trivially identified during the parsing stage, and used as needed. 
The start symbol and start rule (the production associated with the start symbol) are hence defined as in \autoref{lst:the_start_symbol_and_start_rule_for_metaspec}.

\begin{listing}[!htb]
\begin{minted}[numbers=none, fontsize=\blockfont]{text}
start-symbol-start = "<<";
start-symbol-end = ">>";
start-symbol = start-symbol-start, non-terminal-identifier, start-symbol-end;
start-rule = start-symbol, defining-symbol, language-rule-body;
\end{minted}
\caption{The Start Symbol and Start Rule for Metaspec}
\label{lst:the_start_symbol_and_start_rule_for_metaspec}
\end{listing}

% subsection specification_of_the_language_start_rule (end)

\subsection{Removal of the Empty Syntax} % (fold)
\label{sub:removal_of_the_empty_syntax}
As part of its syntactic specification, \gls{ebnf} provides the notion of an `empty syntax'.
This is a piece of syntax that can exist when there is no actual syntax in a place where some would otherwise be expected. 
As one might imagine, this poses some significant difficulties to parsers, and hence has been removed in Metaspec for practical purposes. \\

There were some concerns that this would compromise the expressive power of the metasyntactic notation used in Metaspec, but careful examination of the \gls{ebnf} standard only showed one case where the empty syntax was used. 
\gls{ebnf} provides facilities for a syntactic exception, and this can be combined with the repetition notation and empty syntax to ensure that at least one repetition exists: \mintinline{text}{prod = {some-term}-;}.
While not allowing this notation does compromise the \textit{conciseness} of certain productions in Metaspec, it does not prevent representation of such terms --- the above can be represented as \mintinline{text}{prod = some-term, {some-term};}.

% subsection removal_of_the_empty_syntax (end)

\subsection{Altering the Assignment Operator} % (fold)
\label{sub:altering_the_assignment_operator}
One of the other changes that \gls{metaspec} makes to the standard \gls{ebnf} notation for language productions is to alter the assignment symbol.
Where \gls{ebnf} uses \mintinline{text}{=}, \gls{metaspec} uses \mintinline{text}{::=}.\\

The reasoning behind this is similar to some of the reasoning for redefining the form of non-terminals: it provides a more significant visual cue to the language designer. 
As the \mintinline{text}{=} symbol often appears in programming languages as some form of assignment, it is not unlikely that a \gls{dsl} designer would want to use it as such.
This means that it would have to occur in a production as \mintinline{text}{"="}. 
The \mintinline{text}{::=} as chosen by \gls{metaspec} is far less common, and this should help to improve the readability of the syntactic notation at a glance. 

% subsection altering_the_assignment_operator (end)

\subsection{The Final Language Syntax} % (fold)
\label{sub:the_final_language_syntax}
As a result, the final syntactic metalanguage for \gls{metaspec} is very similar to that of \gls{ebnf}.
Including the changes mentioned in the preceding sections, it is capable of the specification of flexible syntactic rules containing the following syntactic features:
\begin{itemize}
    \item Optionality of syntax.
    \item Grouping of syntax.
    \item Alternation of syntax terms.
    \item Repetition, in both the multiplicative (\mintinline{text}{3 * <nt>}) and repeated-group (\mintinline{text}{{<nt>}}) forms, for syntax terms.
    \item Syntactic exceptions (\mintinline{text}{<nt1> - <nt2>}).
    \item Arbitrary non-terminals and terminals.
\end{itemize}

Overall, this provides an excellent metasyntactic foundation for the metalanguage, and lets users describe a wide-set of possible languages.
Hence, it allows \gls{dsl} designers to get as close to their intended domain-specific notation as possible. 

% subsection the_final_language_syntax (end)

% section specifying_the_language_syntax (end)

\section{Specifying the Language Semantics} % (fold)
\label{sec:specifying_the_language_semantics}
While \gls{metaspec} now had a way of specifying language syntax, its hybrid nature meant that it also needed a way to specify the language semantics. 
As discussed in \autoref{sub:choosing_a_semantic_form}, the basic semantic descriptions in metaspec are based on big-step operational semantics (see Subsection~\ref{ssub:operational_semantics}). 
However, requirements dictated that the language support other forms of semantics, including environment accesses (Requirement~\reqref{req:EnvironmentAccesses}) and special-case semantic rules (Requirement~\reqref{req:SpecifyLanguageSemantics}).\\

As a result, the metalanguage has four different kinds of semantic rules, each of which is explored below:
\begin{itemize}
    \item \textbf{Standard Semantics:} These are an adaptation of the big-step operational semantics form.
    They provide restrictions and evaluation control, and are the main method for specifying language semantics.
    \item \textbf{Special-Case Semantics:} These special rules have a distinct syntactic form, and provide semantics that cannot be proved by the standard mechanism.
    \item \textbf{Environment Accesses:} Accesses to items stored in the global environment, akin to a key-value store.
    \item \textbf{Environment Stores:} The ability to store values in the global environment under a key. 
\end{itemize}

The following sections aim to explain the design process that the syntax for the semantic forms underwent, broadly grouping them into the categories of ``User-Defined Semantics'' (\autoref{sub:user_defined_semantics}), which took the most design effort, and ``Special-Case Semantics'' (\autoref{sub:special_case_semantics}).

\subsection{Accessing Syntax from the Semantics} % (fold)
\label{sub:accessing_syntax_from_the_semantics}
One of the first things to notice about the form of a big-step operational semantics rule (see \autoref{eq:example_of_big_step_operational_semantics_if} for an example) is that the sub-evaluations (those above the evaluation line) usually contain sub-terms of the main expression (below the line).
It should be noted that, in the general, non-metaspec case, these sub-evaluations do not \textit{have} to be purely sub-terms of the main expression. 

\begin{equation}
    [\text{if}] : \frac{\langle S_1, s \rangle \to s'}{\langle \text{if } b \text{ then } S_1 \text{ else } S_2, s\rangle \to s'} \text{ if } \mathbb{B}\llbracket b \rrbracket s = \text{true}
    \label{eq:example_of_big_step_operational_semantics_if}
\end{equation}

In a basic sense, every piece of syntax in Metaspec has some kind of semantics associated with it.
As a result, the syntax often defines the `main expression' of the semantic rule.
Given this fact, \gls{metaspec} needs a way for the semantic rules to `access' the syntax, that is: refer directly to portions of the syntax of a given production. \\

As has been established in \autoref{sec:specifying_the_language_syntax}, \gls{metaspec} supports a flexible notation for defining productions of the DSL. 
However, the important thing to recognise is that the only terms that one would need to refer to in the semantics are the non-terminals of the language. 
Any syntactic production decomposes to a set of terminals and non-terminals, and as terminals are fixed they can be explicitly written into the semantics where required. \\

\begin{listing}[!htb]
\begin{minted}[numbers=none]{text}
<example> ::= <foo> "(" <bar> "," <bar> ")"
\end{minted}
\caption{An Example Production for Syntax Access}
\label{lst:an_example_production_for_syntax_access}
\end{listing}

Consider an example production of the form seen in \autoref{lst:an_example_production_for_syntax_access}. 
The most intuitive way to access the syntax is to refer directly to the non-terminals directly.
This means that \mintinline{text}{<foo>} in the semantics would refer to the first instance of the non-terminal in the syntax, and similarly for \mintinline{text}{<bar>}.
However, this positional argument-based nature is a non-intuitive way to access the syntax, as it forces the \gls{dsl} designer to formulate their semantics in the order of the syntax. 
This would impose significant restrictions in the case of semantic special syntax (which have fixed argument positions), and was hence seen as undesirable.\\

As the above situation was deemed unsatisfactory, the final access form for \gls{metaspec} takes inspiration from array accesses in other programming languages, using the square-bracket notation (\mintinline{text}{[]}) for familiarity.
Each access into the syntax must hence specify the (zero-indexed) \textit{position} of the specific non-terminal to which it refers: \mintinline{text}{<bar>[1]} refers to the second instance of the non-terminal, for example.
These positions must hence be checked at language verification time (see \autoref{sub:user_defined_semantic_form_verification} for details).\\

This provides an intuitive way to access syntactic elements within the semantics, without restricting the form in which the semantics can be written. 

% subsection accessing_syntax_from_the_semantics (end)

\subsection{Semantic Typing} % (fold)
\label{sub:semantic_typing}
The semantics are the location where the notion of data types was designed into \gls{metaspec} with each semantic rule carrying some type information. 
This was imposed upon the language by Requirement~\reqref{req:SemanticTyping} for two main reasons:
\begin{itemize}
    \item \textbf{Conciseness:} A common feature of \glspl{dsl} is that they have a clear and concise syntax that matches the domain representation of knowledge as closely as possible (\autoref{sec:domain_specific_languages}). 
    As a result, having typing imposed at the syntactic level would add unnecessary visual clutter to the \gls{dsl} syntax. 
    \item \textbf{Clarity of Language Implementation:} It would likely introduce significant complexity to the form of the language semantics to introduce a method for providing syntactic typing to the language designer.
    Furthermore, the provision of such a feature would likely require alterations to the verification algorithm, and hence potentially impact correctness. 
\end{itemize}

To this end, it was decided to impose types at the semantic level.
In this case, each semantic expression (where the type could not be inferred) is required to have a result type, where the types may be one of the types allowed by the current language context. 
These types are expressions as part of the language grammar, and are contextually checked to be in scope at parse time (see \autoref{sub:metaparse_ast_generation}).\\

For information on the checking of types in the language specification, please see \autoref{sub:type_checking} on \autopageref{sub:type_checking}. 

% subsection semantic_typing (end)

\subsection{User-Defined Semantics} % (fold)
\label{sub:user_defined_semantics}
While \textit{all} semantics for a language designed in \gls{metaspec} are technically user-defined, this section focuses on the examination of the main form of the semantics --- those based upon big-step operational semantics. 
These semantic rules form core of languages written in \gls{metaspec}, as they provide a flexible way to specify the behaviour of the language. 

\subsubsection{Examining the form of Big-Step Operational Semantics} % (fold)
\label{ssub:examining_the_form_of_big_step_operational_semantics}
\begin{equation}
    [\text{if}] : \frac{\langle S_1, s \rangle \to s'}{\langle \text{if } b \text{ then } S_1 \text{ else } S_2, s\rangle \to s'} \text{ if } \mathbb{B}\llbracket b \rrbracket s = \textit{ true} 
    \label{eq:a_basic_big_step_operational_semantics_rule}
\end{equation}

A big-step operational rule such as the one seen in \autoref{eq:a_basic_big_step_operational_semantics_rule} can be broken down into a number of components:
\begin{itemize}
    \item \textbf{The Primary Expression:} \label{item:the_primary_expression} This is the portion of the syntax to be evaluated below the line, to the left of the evaluation arrow.
    Here, this is: $\langle \text{if } b \text{ then } S_1 \text{ else } S_2, s \rangle$.
    \item \textbf{The Evaluation Result:} The result of evaluating the primary expression, this is found to the right of the evaluation arrow below the line.
    Here it is: $s'$. 
    \item \textbf{The Restriction:} A restriction placed on the evaluation of this rule, such that the rule is only evaluated if the restriction holds. 
    Here, this is: $\text{if } \mathbb{B}\llbracket b \rrbracket s = \textit{ true}$.
    \item \textbf{The Sub-Evaluation:} A specification of how each component of the primary expression is evaluated, located above the line.
    Here, this is: $\langle S_1, s \rangle \to s'$. 
\end{itemize}

There are further components that are not indicated in such a rule. 
Consider the rule shown in \autoref{eq:an_alternate_big_step_operational_semantics_rule}.

\begin{equation}
    [+] : \frac{\langle A_1, s_0\rangle \to \langle n_1, s_1\rangle \;\;\;\; \langle A_2, s_1 \rangle \to \langle n_2, s_2\rangle}{\langle A_1 + A_2, s_0 \rangle \to \langle n, s_2 \rangle}\;\; n = n_1 + n_2
    \label{eq:an_alternate_big_step_operational_semantics_rule}
\end{equation}

This exhibits an additional set of components as follows:
\begin{itemize}
    \item \textbf{The Semantic Evaluation:} This is a portion of the rule that specifies how the result of the semantics is calculated, located to the right of the evaluation rule. 
    Here, it is: $n = n_1 + n_2$.
    \item \textbf{Multiple Sub-Evaluations:} This rule also illustrates that it is possible to have multiple sub-evaluations taking place as part of a given semantic rule. 
    The importance of this is the \textit{order} in which they are executed, as this may impact the results of computations.
    While this importance is not necessarily apparent at the level of a semantic specification, it becomes important when generating execution semantics from the definition. 
    For further discussion of this issue, see \nameref{ssub:verifying_the_evaluation_criterion} on \autopageref{ssub:verifying_the_evaluation_criterion}.
\end{itemize}

Each of these components must be accounted for in the semantic form that represents these semantic rules, and have been incorporated into the metasyntax for the semantics as discussed in \autoref{ssub:the_final_form_of_the_user_defined_semantics}.

% subsubsection examining_the_form_of_big_step_operational_semantics (end)

\subsubsection{Transforming Big-Step Operational Semantics} % (fold)
\label{ssub:transforming_big_step_operational_semantics}
Having identified the key portions of the big-step semantic rules, the next task was to represent these components effectively in a textual format. 
The working assumption for designing this syntactic representation is that these \gls{metaspec} language specifications would be written with nothing but a text editor, as specified by Requirement~\reqref{req:TextEditorReady}.
To this end, the notation should be simplistic and not require complex formatting (thus also simplifying the parsing process). \\

In one sense, semantics represent a flow of information or a \textit{pipeline} of evaluation. 
Semantically, each portion of the evaluation is predicated on the next portion of the evaluation, so they can be separated by what is effectively a \textit{where} clause. 
For the purposes of these semantic rules, the \mintinline{text}{:} operator was chosen to represent this.
To this end, the portions of the semantic rules discussed in \autoref{ssub:examining_the_form_of_big_step_operational_semantics} can be represented in order as follows:
\begin{enumerate}
    \item \textbf{The Output Variable:} A variable identifier and associated type (as discussed in \autoref{sub:semantic_typing}) as the leftmost portion of the rule: \mintinline{text}{<type> <identifier>}.
    This variable defines the final result of the semantic evaluations.
    \item \textbf{The Semantic Operations:} A list of operations that define how the results of the sub-evaluations are combined: \mintinline{text}{(<eval> {"," <eval>})}.
    These operations are defined in terms of an allowed set of semantic operations defined by metaspec. 
    \item \textbf{The Semantic Restrictions:} A list of restrictions that constrain the circumstances under which this semantic rule can operate.
    These are restrictions on the results of the sub-evaluations that act as boolean conditions, and hence look like a list of standard conditions: \mintinline{text}{([<key> <op> <key>] {"," <key> <op> <key>})}.
    Restrictions do not have to exist, however, and hence it is perfectly valid to have an empty restriction block.
    \item \textbf{The Semantic Evaluations:} These define evaluations on sub-terms of the syntax, with each sub-term addressing non-terminals as discussed in \autoref{sub:accessing_syntax_from_the_semantics}. 
    Each of these terms must define a result type and variable for use in the semantic operations section: \mintinline{text}{<type> <identifier> "<=" <syntax-access>}.
    As there can be multiple of these, they are given as a list.
\end{enumerate}

\begin{listing}[!htb]
\begin{minted}[firstnumber=315]{text}
semantic-evaluation-rule = 
    semantic-type,
    semantic-identifier,
    where-symbol,
    semantic-operation-list,
    semantic-restiction-list,
    where-symbol, 
    semantic-eveluation-list;
\end{minted}
\caption{The Semantic Evaluation Rule Grammar}
\label{lst:the_semantic_evaluation_rule_grammar}
\end{listing}

It is apparent at this point that the \textit{primary expression} identified on \autopageref{item:the_primary_expression} appears to have been ignored.
While it was initially included as a component in the semantic rule it was quickly noticed that the syntax of the language production itself suffices as the primary expression.
It was hence omitted from the semantics directly, with the syntax accesses (see \autoref{sub:accessing_syntax_from_the_semantics}) sufficing to combine the two. 
The final basic form of the syntax for these semantic rules can be seen in \autoref{lst:the_semantic_evaluation_rule_grammar}.\\

Combining these elements provides the form for a single evaluation rule.
A single rule is, however, not sufficient to represent a defined set of semantics for a given production. 
As a result, the grammar was expanded to accommodate a `semantic alternation', with multiple semantic rules separated by \mintinline{text}{|}, appearing as a logical disjunction.
This notion perfectly represents the concept, as only one semantic rule will evaluated based upon the evaluation of the guards. 
This is represented in the concept of the evaluation list, as defined in \autoref{lst:the_semantic_evaluation_rule_list}.

\begin{listing}[!htb]
\begin{minted}[firstnumber=312]
semantic-evaluation-rule-list = 
    semantic-evaluation-rule,
    { semantic-disjunction, semantic-evaluation-rule };
\end{minted}
\caption{The Semantic Evaluation Rule List}
\label{lst:the_semantic_evaluation_rule_list}
\end{listing}

Multiple portions of this syntax are required to match a certain form for verification to be able to occur. 
These restrictions are discussed in detail in \autoref{sub:user_defined_semantic_form_verification}, and are crucial to the ability of \gls{absol} to verify the language semantics.

% subsubsection transforming_big_step_operational_semantics (end)

\subsection{An Example of User-Defined Semantics} % (fold)
\label{sub:an_example_of_user_defined_semantics}
Having established the form of the semantics as above, it is now possible to formulate an example of the transformation from standard big-step operational semantics to the \gls{metaspec} syntax for the same.
Consider the rules for exponentiation as described in Equations~\ref{eq:big_step_exponentiation_special_case} and~\ref{eq:big_step_exponentiation_base_case} below.
These rules have a special case for illustrative purposes. 

\begin{align}
    [\string^] &: \frac{\la A_2, s_0 \ra \to \la n_2, s_1 \ra}
    {\la A_1 \string^ A_2, s_0 \ra \to \la n, s_1 \ra} n = 1 \text{ where } n_2 == 0 \label{eq:big_step_exponentiation_special_case} \\
    [\string^] &: \frac{\la A_2, s_0 \ra \to \la n_2, s_1 \ra \;\;\; \la A_1, s_1 \ra \to \la n_1, s_2 \ra}{\la A_1 \string^ A_2, s_0 \ra \to \la n, s_2 \ra} n = n_1^{n_2} \label{eq:big_step_exponentiation_base_case}
\end{align}

Working through the special-case rule in \autoref{eq:big_step_exponentiation_special_case} it is possible to compose the equivalent \gls{metaspec} expression as follows (assuming types and that $A_1, A_2$ are the same non-terminal): 
\begin{enumerate}
    \item \textbf{Determine the Output Variable:} In this case it is clear that it is $n$. 
    The expression is hence initially:
    \begin{minted}[xleftmargin=2cm, numbers=none]{text}
        number n : 
    \end{minted}
    \item \textbf{Determine the Evaluation Rule:} This is also clear as $n = 1$, in the presence of a restriction.
    The Metaspec rule is hence:
    \begin{minted}[xleftmargin=2cm, numbers=none]{text}
        number n : {n = 1}
    \end{minted}
    \item \textbf{Determine any Restrictions:} This rule has a restriction, and so this can also be found and added. 
    It is $n_2 == 0$, making the Metaspec rule into:
    \begin{minted}[xleftmargin=2cm, numbers=none]{text}
        number n : {n = 1}(n2 == 0) : 
    \end{minted}
    \item \textbf{Write the Sub-Evaluations:} This rule only has a single sub-evaluation as follows: $\la A_2, s_0 \ra \to \la n_2, s_1 \ra$.
    This is transformed into Metaspec, giving the resultant rule (as it is the \textit{second} instance of that `non-terminal' in the rule):
    \begin{minted}[xleftmargin=2cm, numbers=none]{text}
        number n : {n = 1}(n2 == 0) : {number n2 <= <a-nt>[1]}
    \end{minted}
\end{enumerate}

Performing the same process for the generic exponentiation rule in \autoref{eq:big_step_exponentiation_base_case} and combining using an alternation (as discussed on \autopageref{ssub:transforming_big_step_operational_semantics}), the final semantic expression can be found.
This is seen in \autoref{lst:metaspec_semantic_rules_for_exponentiation}, and can be assumed to be linked to a syntactic rule of the form \mintinline{text}{<exp> ::= <a-nt> "^" <a-nt>;} (or similar).

\begin{listing}[!htb]
\begin{minted}[numbers=none]{text}
number n : {n = 1}(n2 == 0) : {number n2 <= <a-nt>[1]} |
number n : {n = n1 ^ n2}() : 
    {number n2 <= <a-nt[1]}, {number n1 <= <a-nt>[0]}
\end{minted}
\caption{Metaspec Semantic Rules for Exponentiation}
\label{lst:metaspec_semantic_rules_for_exponentiation}
\end{listing}

% the user is able to decide which evaluations to make, and in which order

% subsection an_example_of_user_defined_semantics (end)

\subsubsection{The Final Form of the User-Defined Semantics} % (fold)
\label{ssub:the_final_form_of_the_user_defined_semantics}
At this point, the syntax for defining language semantics is concise and clear.
However, it has not yet been established exactly how one of these operations is evaluated.
Much like the big-step operational semantics from which they are derived, the evaluation semantics are crucial to understanding these expressions. \\

As a result, it is important to formalise the evaluation semantics of the metaspec expressions. 
A metaspec semantic rule is evaluated according to the algorithm given in \autoref{alg:metaspec_semantic_evaluation_algorithm}, taking an alternation of metaspec semantic rules as input.
Assume that \textsc{evaluate} is a function that evaluates the provided evaluation or computation, and that \textsc{checkRestriction} is a function that returns true if the restrictions are all true.
With formalised execution order, this ensures that the \gls{dsl} creators are provided with full control over the execution semantics of their language.

\begin{breakablealgorithm}
\caption{Metaspec Semantic Evaluation Algorithm}
\label{alg:metaspec_semantic_evaluation_algorithm}
\begin{algorithmic}
\State rules $\gets$ the alternation of semantic rules
\State
\ForAll{rule $\in$ rules}
    \State evals $\gets$ sub-evaluations in rule
    \State computations $\gets$ semantic evaluations in rule
    \State restrictions $\gets$ restrictions in rule
    \State 
    \ForAll {eval $\in$ evals}
        \State \textbf{evaluate}(eval)
    \EndFor
    \State
    \If{\Call{checkRestrictions}{restrictions}}
        \ForAll {computation $\in$ computations}
            \State \Call{evaluate}{computation}
            \Comment Order of evaluation enforced (see \autopageref{ssub:verifying_the_evaluation_criterion})
        \EndFor
        \State
        \State output the result
        \State \textbf{terminate}
    \Else
        \State \textbf{continue}
    \EndIf
\EndFor
\end{algorithmic}
\end{breakablealgorithm}

% subsubsection the_final_form_of_the_user_defined_semantics (end)

% subsection user_defined_semantics (end)

\subsection{Special-Case Semantics} % (fold)
\label{sub:special_case_semantics}
In addition to the user-defined semantics based upon the big-step operational semantics, Requirements~\reqref{req:EnvironmentAccesses} and~\reqref{req:ExtensionMechanisms} mean that other kinds of semantics must be defined.
These include the special-case semantics for providing language features that cannot be proved by the termination mechanism, and semantic rules for environment accesses and stores.
The below sections explore the design of these additional semantic features.

\subsubsection{Semantic Special Syntax} % (fold)
\label{ssub:semantic_special_syntax}
The semantic \glspl{ssr} are a method for \gls{metaspec} to provide additional, useful language features that cannot be proven by the usual termination proof mechanism. 
While they might technically be able to be expressed in big-step operational semantics, the restrictions placed on the standard semantic form (\autoref{sub:user_defined_semantics}) mean that they cannot be expressed in metaspec.
This includes features like data traversal and function calls. \\

The syntactic design for these pieces of special syntax was inspired by the notion of `library functions' in other languages.
Much like Haskell has \mintinline{haskell}{fmap fn s}, these pieces of special syntax provide advanced functionality to the user for little effort on their part.
As a result, the syntax was designed to look like a function call: \mintinline{text}{<ssr> "("[<arg>] {"," <arg>} ")"}.\\

\begin{listing}[!htb]
\begin{minted}[firstnumber=304, fontsize=\blockfont]{text}
special-syntax-rule = 
    semantic-special-syntax,
    special-syntax-start,
    [ syntax-access-block | environment-access-rule ],
    { semantic-list-delimiter, (syntax-access-block|environment-access-rule) },
    special-syntax-end;
\end{minted}
\caption{Semantic Special Syntax}
\label{lst:semantic_special_syntax}
\end{listing}

Syntactically, they consist of a language keyword and an argument list, and the exact semantics of each is defined in \autoref{sec:special_language_features}.
The argument list may consist of syntax accesses (see \autoref{sub:accessing_syntax_from_the_semantics} or environment accesses (see \autoref{ssub:environment_access_rules}), the latter of which allow them to retrieve values from the environment.
They are described by the \gls{ebnf} expression in \autoref{lst:semantic_special_syntax} and are subject to verification as described in \autoref{ssub:verification_of_special_syntax_rules}.\\

These \glspl{ssr} can occur inside the user-defined semantics (\autoref{sub:user_defined_semantics}) as they can provide useful functionality for defining the semantics of more complex expressions.
In allowing them to be nested in such expressions, it removes the need to indirect through another non-terminal where these might occur. 
This brings no additional complexity to the proof mechanism and brings the potential for additional simplicity to the language specification.
This is likely to somewhat reduce the potential for bugs. 

% subsubsection semantic_special_syntax (end)

\subsubsection{Environment Input Rules} % (fold)
\label{ssub:environment_input_rules}
Environment input rules are intended to provide mechanisms for \gls{dsl} designers to store and retrieve values in the environment. 
The environment was conceptualised as an unscoped key-value store to allow for variable definitions, function definitions and any other use that the user can come up with. \\

Syntactically, the environment was represented by a special reserved symbol in \gls{metaspec}, \mintinline{text}{e}. 
The notion behind this was to ensure that all environment stores and accesses could be found at a glance by the user, aiding their understanding of any stateful behaviour in the language semantics. 
Unfortunately this has turned out to not be entirely true, as some special syntax calls define (or access) elements in the environment without direct use of the symbol.\\

Beyond that, the store into the environment uses a newly introduced operator \mintinline{text}{<--}. 
This operator was designed to visually mimic the \mintinline{haskell}{<-} monadic extraction operator, and aims to imply getting something out of the syntax and storing it somewhere else. 
Stores in the environment operate in a key-value function, with the key and value separated by the \mintinline{text}{:} (defining) symbol.
In short: \mintinline{text}{e <-- <key>[n] : <values...>}, for some arbitrary non-terminals \mintinline{text}{<key>} and \mintinline{text}{<values>}.
Environment input rules are hence defined by the \gls{ebnf} expression given in \autoref{lst:environment_input_rules}.

\begin{listing}[!htb]
\begin{minted}[firstnumber=279]{text}
environment-input-rule =
    semantic-type, 
    semantic-environment-symbol,
    semantic-environment-input-symbol,
    syntax-access-block, (* key *)
    environment-defines-symbol,
    syntax-access-list;
\end{minted}
\caption{Environment Input Rules}
\label{lst:environment_input_rules}
\end{listing}

% subsubsection environment_input_rules (end)

\subsubsection{Environment Access Rules} % (fold)
\label{ssub:environment_access_rules}
Much like for environment inputs, environment accesses also took syntactic inspiration from features of common programming languages. 
Initial syntax for the environment accesses treated it much like a dictionary, where a key was given to retrieve a value: \mintinline{text}{e[<key>]}.
However, it is possible that certain structures in the environment have properties of their own, and it was immediately apparent that it could be syntactically awkward to access these.\\

To remove this awkwardness, the final syntax in \gls{metaspec} defines \mintinline{text}{.} as the environment access symbol, taking inspiration from object property access in most C++ derived languages.
The idea behind this is that it can be chained in a visually pleasing way, accessing properties in the environment and the environment's children: \mintinline{text}{e.<nt-1>.<nt-2> ...}
These accesses are based on the syntax of the triggering rule, and hence the \gls{ebnf} expression for such productions is as in \autoref{lst:environment_access_rules}.

\begin{listing}[!htb]
\begin{minted}[firstnumber=297]{text}
environment-access-rule = 
    semantic-environment-symbol,
    environment-access-symbol,
    syntax-access-block,
    { environment-access-symbol, syntax-access-block }; 
\end{minted}
\caption{Environment Access Rules}
\label{lst:environment_access_rules}
\end{listing}

% subsubsection environment_access_rules (end)

% subsection special_case_semantics (end)

% section specifying_the_language_semantics (end)

\section{Combining Syntax and Semantics} % (fold)
\label{sec:combining_syntax_and_semantics}
With a robust metasyntactic format for both syntax and semantics in \gls{metaspec}, the remaining challenge of the metalanguage was to combine the two. 
This combination is crucial to the design of the language, as stated in Requirement~\reqref{req:IntegratedSyntaxandSemanticSpecification}.
The combination of the two had to admit all of the four categories of semantic rule (see \autoref{sec:specifying_the_language_semantics}), and associate them with a syntactic production, and hence the choice of both \textit{syntax} and the \textit{combination point} was important. 

\subsection{Choosing the Combination Syntax} % (fold)
\label{sub:choosing_the_combination_syntax}
As the marriage of syntax and semantic specification is at the crux of \gls{metaspec} itself, the syntax for combining the two metasyntactic notations had some significance. \\

The initial inspiration for the syntax came from the notion of logical implication: that the syntax implied a given behaviour. 
There were concerns, however, about this being too literal an idea, and hence rather than \mintinline{text}{->}, the extended arrow operator (\mintinline{text}{-->}) was used. 
This was coupled with a block syntax, wrapping all the semantics for a given production up in braces (\mintinline{text}{{}}) to act as a visual delimiter.
The resultant \gls{ebnf} production can be seen in \autoref{lst:language_rule_semantics}. 

\begin{listing}[!htb]
\begin{minted}[firstnumber=267]{text}
language-rule-semantics = 
    semantic-behaves-as,
    semantic-block-start,
    semantic-rule,
    semantic-block-end;
\end{minted}
\caption{Language Rule Semantics}
\label{lst:language_rule_semantics}
\end{listing}

% subsection choosing_the_combination_syntax (end)

\subsection{Determining the Combination Point} % (fold)
\label{sub:determining_the_combination_point}
Just as important as the combination syntax was the choice of where to combine the syntactic and semantic descriptions.\\

The initial choice of the connection point went somewhat awry, with the grammar specifying that the semantics came directly after the full syntactic specification: \\
\mintinline{text}{production, "-->", "{", semantics, "}"}.
For some fairly obvious reasons, this did not work.
All of these boil down to one essential fact: syntactic productions contain alternations:
\begin{itemize}
    \item It is trivial to imagine a production where a non-terminal \mintinline{text}{<a>} occurs in the first alternation and is referred to in the semantics, but does not occur in the second alternation. 
    \item It is just as simple to imagine each alternations containing different terminal symbols (e.g. \mintinline{text}{<a> "+" <a> | <a> "-" <a>}) which may want to result in different behaviour. 
\end{itemize}

Clearly, the semantics should instead be specified at the level of the alternation instead: \mintinline{text}{<a> --> {} | <b> --> {} | ...} and so on.
This provides the maximum amount of flexibility to the language designers, allowing them to specify more complex productions that are logically grouped. An example of this is the `arithmetic operation' production shown in \autoref{lst:arithmetic_operations_in_metaspec}.\\

\begin{listing}[!htb]
\begin{minted}[numbers=none]{text} 
<arith-op> ::=
    <arith-expr> "+" <arith-expr> --> {
        num n : {n = n1 + n2}() :
            {num n1 <= <arith-expr>[0]}, {num n2 <= <arith-expr>[1]}
    } |
    <arith-expr> "-" <arith-expr> --> {
        num n : {n = n1 - n2}() :
            {num n1 <= <arith-expr>[0]}, {num n2 <= <arith-expr>[1]}
    } |
    <arith-expr> "*" <arith-expr> --> {
        num n : {n = n1 * n2}() :
            {num n1 <= <arith-expr>[0]}, {num n2 <= <arith-expr>[1]}
    } |
    <arith-expr> "/" <arith-expr> --> {
        num n : {n = n1 / n2}() :
            {num n1 <= <arith-expr>[0]}, {num n2 <= <arith-expr>[1]}
    } |
    <arith-expr> "^" <arith-expr> --> {
        num n : {n = n1 ^ n2}() :
            {num n1 <= <arith-expr>[0]}, {num n2 <= <arith-expr>[1]}
    };
\end{minted}
\caption{Arithmetic Operations in Metaspec}
\label{lst:arithmetic_operations_in_metaspec}
\end{listing}

It is hence clear that the decision to associate semantics with each block in a top-level alternation is the most flexible choice for \gls{metaspec} and affords the \gls{dsl} designers the most flexibility without creating an overly convoluted syntax. 

% subsection determining_the_combination_point (end)

% section combining_syntax_and_semantics (end)

% chapter designing_the_metalanguage (end)
