\newdualentry{dsl}{DSL}{Domain-Specific Language}{
    An abstraction of the problem domain in the form of a `small' programming language that provides appropriate notations and expressive power focused on a particular problem domain. 
}

\newglossaryentry{semantics}{
    name=Semantics,
    text=semantics,
    description={
        The definition of meaning of syntactically valid (see \gls{syntax}) strings in a language.
        This meaning defines how these programs \textit{behave} when executed, or as the \textit{effect} of executing these programs.
    }
}

\newglossaryentry{syntax}{
    name=Syntax,
    text=syntax,
    description={
        The ways in which the terminal symbols of a programming language may be combined to create programs that are well-formed in the language.
    }
}

\newdualentry{absol}{ABSOL}{Automatic Builder for Semantically Oriented Languages}{
    The \gls{metacompiler} program and toolchain that performs language analysis and verification.
}

\newglossaryentry{metacompiler}{
    name=Metacompiler,
    text=metacompiler,
    description={
        A metacompiler is a program that takes in a specification and generates code for a language compiler as its output. 
        In the case of this project, the metacompiler is responsible for the verification of the input specification, rather than code generation from it. 
    }
}

\newglossaryentry{halting_problem}{
    name=Halting Problem,
    description={
        The Halting Problem describes the problem of determining, from a description of an arbitrary computer program ($\delta$), for a Turing-Machine or equivalent, and an arbitrary input $x$ whether $\delta$ will complete execution or continue to run forever (\gls{diverge}) \citep{boyer1984mechanical}. 
    }
}

\newglossaryentry{declarative}{
    name=Declarative,
    text=declarative,
    description={
        A style of programming language that allows the user to express the logic of a computation without expressing the exact set of steps to be executed. 
        Examples include some portions of Haskell, and Prolog. 
    }
}

\newacronym{avopt}{AVOPT}{Analysis, Verification, Optimisation, Parallelisation and Transformation}

\newglossaryentry{transpilation}{
    name=Transpilation,
    text=transpilation,
    description={
        The transformation of one high level language $L_1$ into another $L_2$ via the \gls{ast} created from parsing $L_1$. 
        The \gls{ast} is used to generate code in the \textit{target} language ($L_2$), aiming to preserve the semantics of $L_1$ as accurately as possible. 
    }
}

\newdualentry{ast}{AST}{Abstract Syntax Tree}{
    An Abstract Syntax Tree (AST) is a tree-based representation of the syntactic structure of the source code of a program or other unit in some language, without any of the extraneous information required for parsing.
    It is the ideal form for programmatic manipulation of the language unit.
}

\newglossaryentry{source_map}{
    name=Source Map,
    text=source map,
    description={
        A predefined mapping of debug symbols in the target language back to the debug symbols in the source language \citep{kulkarnitranspiler}.
    }
}

\newacronym{bnf}{BNF}{Backus-Naur Form}

\newacronym{ebnf}{EBNF}{Extended Backus-Naur Form}

\newacronym{ffi}{FFI}{Foreign-Function Interface}

\newglossaryentry{metaspec}{
    name=Metaspec,
    description={
        The \gls{metalanguage} designed as part of the \acrshort{absol} project. 
        It is capable of describing both \gls{syntax} and \gls{semantics} of the target DSL with one unified syntax. 
    }
}

\newglossaryentry{metalanguage}{
    name=Metalanguage,
    text=metalanguage,
    description={
        A metalanguage is a language that is, itself, used to describe aspects of another language \citep{jakobson1980metalanguage}. 
    }
}

\newacronym{vcs}{VCS}{Version Control System}

\newglossaryentry{defblock}{
    name=Defblock,
    description={
        A defblock is a top-level definition block in \gls{metaspec}. 
    }
}

\newacronym{ssr}{SSR}{Special-Syntax Rule}

\newacronym{cli}{CLI}{Command-Line Interface}

\newglossaryentry{lexer}{
    name=Lexer,
    text=lexer,
    description={
        A lexer is a program that takes a string of characters and performs a process known as \textit{lexical analysis} to generate a stream of tokens (each of which may consist of one or more characters).
        Each of these tokens has semantic meaning in a given language.
    }
}

\newglossaryentry{parser}{
    name=Parser,
    text=parser,
    description={
        A parser is a program that takes a string of tokens (usually from a \gls{lexer}) and builds an \acrshort{ast} for out of these tokens based on the language grammar. 
    }
}

\newglossaryentry{diverge}{
    name=Diverge,
    text=diverge,
    description={
        A computer program is said to \textit{diverge} if it never terminates or terminates in some unintended or exceptional state.
    }
}

\newglossaryentry{group}{
    name=Group,
    text=group,
    description={
        A group is a structure $(G, \cdot)$ where $G$ is a set and $\cdot$ is an associative binary operation on elements of $G$.
        A group satisfies the following axioms:
        \begin{itemize}
            \item \textbf{Closure:} $\forall a, b \in G, a \cdot b \in G$
            \item \textbf{Associativity:} $\forall a, b, c\in G, (a \cdot b) \cdot c = a \cdot (b \cdot c)$.
            \item \textbf{Identity:} $\exists! e \in G. \forall a \in G, e \cdot a = a \cdot e = a$
            \item \textbf{Inverse:} $\forall a \in G. \exists b \in G, a \cdot b = b \cdot a = e$, where $e$ is the identity as above.
        \end{itemize}
    }
}

\newglossaryentry{semigroup}{
    name=Semigroup,
    text=semigroup,
    description={
        A semigroup is a structure $(G, \cdot)$ where $G$ is a set and $\cdot$ is an associative binary operation on elements of $G$ such that the following axioms hold:
        \begin{itemize}
            \item \textbf{Closure:} $\forall a, b \in G, a \cdot b \in G$
            \item \textbf{Associativity:} $\forall a, b, c\in G, (a \cdot b) \cdot c = a \cdot (b \cdot c)$.
        \end{itemize}
    }
}

\newglossaryentry{monoid}{
    name=Monoid,
    text=monoid,
    description={
        A monoid is a structure $(G,\cdot)$ where $G$ is a set and $\cdot$ is an associative binary operation on elements of $G$ such that the following axioms hold:
        \begin{itemize}
            \item \textbf{Closure:} $\forall a, b \in G, a \cdot b \in G$
            \item \textbf{Associativity:} $\forall a, b, c\in G, (a \cdot b) \cdot c = a \cdot (b \cdot c)$.
            \item \textbf{Identity:} $\exists! e \in G. \forall a \in G, e \cdot a = a \cdot e = a$
        \end{itemize}
    }
}

\newglossaryentry{noop}{
    name=Noop,
    text=noop,
    description={
        A noop or no-operation is a computer instruction that does nothing, but advances the program counter.
    }
}

\newacronym{ide}{IDE}{Integrated Development Environment}

\newacronym{ghci}{GHCi}{GHC Interpreter}

\newacronym{api}{API}{Application Programming Interface}

\newglossaryentry{dependent_typing}{
    name=Dependent Typing,
    description={
        The ability to encode expressions in the type system that are predicated on values.
        This allows the type system to encode pre- and post-conditions for functions in a dependently-typed language. 
    }
}

\newglossaryentry{dependently_typed}{
    name=Dependently Typed,
    text=dependently typed,
    description={
        See \gls{dependent_typing}.
    }
}

\newacronym{gpl}{GPL}{General-Purpose Programming Language}

\newglossaryentry{domain_specific_logic}{
    name=Domain-Specific Logic,
    text=domain-specific logic,
    description={
        Logic pertaining to how a system operates within its environment. 
    }
}

\newglossaryentry{coupling}{
    name=Coupling,
    text=coupling,
    description={
        The degree of interdependence between components of a software system. 
        High coupling is undesirable as it increases the difficulty of making changes to the system. 
    }
}

\newglossaryentry{undecidable}{
    name=Undecidable,
    text=undecidable,
    description={
        An undecidable computer problem is one for which a yes/no answer is required, but for which there is no possible program that will always compute the correct answer. 
    }
}
