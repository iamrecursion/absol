% How the problem is analysed to create the solution.
% Overall architecture of the design.
% Examine the design approaches taken.
% Identification of areas of the design that account for the requirements and resolve potential conflicts. 
% 

\chapter{Architecture and Algorithms} % (fold)
\label{cha:architecture_and_algorithms}
% This section will contain:
% \begin{itemize}
%     \item \textbf{Architectural Overview:} An overview of the system architecture, linked to the high-level requirements.
%     This will touch on the portions of the system that were ruled out of scope later on, and why.
%     \item \textbf{System Component Examination:} An examination of the design of each of the system components in detail.
%     \item \textbf{The Development of Metaspec:} The process of developing the metaspec language itself, as well as some syntax examples and full syntax description. 
%     \item \textbf{Algorithmic Descriptions:} The verification engine in particular is very heavy on algorithmic work. 
%     These algorithms will be explained here, accompanied by any additional proof work that they require. 
%     This will include proofs for the special form semantics.
%     It will also look at initial or discarded algorithmic designs as part of the process. 
% \end{itemize}

Following on from the design work put into the \gls{metaspec} (see \autoref{cha:designing_the_metalanguage}), significant time and effort was then invested into the design of the metacompiler toolchain itself, as well as the core algorithms and theory that it uses. 
This chapter aims to provide a high-level overview of the \gls{absol} toolchain, showing the main system components and linking these to the high-level requirements.
It also provides a firm background to the design and development of the algorithms utilised by the metacompiler itself, and develops the rigour behind the special-case semantics. 

\section{Designing the Metacompiler --- ABSOL} % (fold)
\label{sec:designing_the_metacompiler_absol}
% TODO Parser: Lexer, Parser, Etc.
% TODO Verifier: Different Verification Modules, talk about the recursive nature. Preprocessor.
% Use this same style of architectural overview in the development section. 
% Architectural overview focuses on system components, not code-level components.
% Suitability of a pipeline-style architecture for the system as a whole. 

As for any large system, it is important to be able to visualise the way in which the individual system components interact and are integrated. 
\gls{absol} itself is composed at a high-level of two main modules, Metaparse and Metaverify.
These modules form a natural segmentation of the work that the compiler has to do, and is are naturally subdivided internally.
\gls{absol} is best visualised as a pipeline, and the arrows illustrate the flow of data through the metacompiler.
The high-level architecture of the metacompiler is illustrated in \autoref{fig:absol_high_level_architectural_diagram} below.\\

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.95\textwidth]{resources/images/metacompiler_pipeline_architecture.pdf}
    \caption{ABSOL High-Level Architectural Diagram}
    \label{fig:absol_high_level_architectural_diagram}
\end{figure}

The main components of the metacompiler can be described as follows:
\begin{itemize}
    \item \textbf{Metaparse:} Responsible for the generation of an \gls{ast} from the input metaspec file and verifying some precondition properties for the verification engine. 
    It has two main stages: lexing and parsing (which also performs precondition verification). 
    For further description of this stage please see \autoref{sub:metaparse_ast_generation}.
    \item \textbf{Metaverify:} Responsible for verifying the termination properties of the language.
    It consists of three main stages: \gls{ast} preprocessing, semantic inference and semantic verification.
    For further description of this stage please see \autoref{sub:metaverify_the_verification_engine}.
\end{itemize}

The following sections provide a detailed exploration of the design of these two main components, with a focus on the reasons behind the design choices that have been made.
Also below is an exploration of how the eventual intention for \gls{dsl} execution and type-checking have impacted the design of the metacompiler itself. 

\subsection{The Metacompiler Front-End} % (fold)
\label{sub:the_metacompiler_front_end}
% Brief discussion on the roles that the front end had to fulfil
% How it acts as a harness around the actual operation of the metacompiler
% CLI Arg parsing

% subsection the_metacompiler_front_end (end)

\subsection{Metaparse --- AST Generation} % (fold)
\label{sub:metaparse_ast_generation}
% Talk about the design for the lexer and parser, informed by the use of Megaparsec.
% Talk about the process and use of datatypes to represent a very strongly typed AST
% Talk about the checks that happen at parse time and reference the appropriate algorithms section.

% subsection metaparse_ast_generation (end)

\subsection{Metaverify --- The Verification Engine} % (fold)
\label{sub:metaverify_the_verification_engine}
% Talk about the different modules, the verification preprocessor, the recursive nature of the algorithm for traversing the metaspec AST.

% subsection metaverify_the_verification_engine (end)

\subsection{Metalanguages and Execution} % (fold)
\label{sub:metalanguages_and_execution}
% How are resultant DSL programs intended to be executed - does this impact the design of the metacompiler at all?

% subsection metalanguages_and_execution (end)

\subsection{Type-Checking} % (fold)
\label{sub:type_checking}
% Explain the ideas behind any and none

% subsection type_checking (end)

% section designing_the_metacompiler_absol (end)

\section{The Core Algorithms} % (fold)
\label{sec:the_core_algorithms}
% Talk about the design of each of the core algorithms in detail.

\subsection{Verifier Precondition Validation} % (fold)
\label{sub:verifier_precondition_validation}

% subsection verifier_precondition_validation (end)

\subsection{Verifier Traversal} % (fold)
\label{sub:verifier_traversal}

% subsection verifier_traversal (end)

\subsection{Basic Semantic Form Verification} % (fold)
\label{sub:basic_semantic_form_verification}
% All three criteria (evals, subterms, etc)
% State the theorem that this algorithm works off.
% Need to build ALL the core theory here. 
% Talk about evaluation ordering and criteria here (how are the sub-evals done, how are the evaluation rules done)?
% Talk about the restrictions placed on the form such that it can be verified

% subsection basic_semantic_form_verification (end)

\subsection{Guard Checking} % (fold)
\label{sub:guard_checking}

% subsection guard_checking (end)

\subsection{Verification of Other Semantic Forms} % (fold)
\label{sub:verification_of_other_semantic_forms}
% The basic user-defined semantics aren't the only kind that exist in metaspec
% Need to detail the algorithms for verification of these other semantic forms.

\subsubsection{Verification of Special-Syntax Rules} % (fold)
\label{ssub:verification_of_special_syntax_rules}

% subsubsection verification_of_special_syntax_rules (end)

\subsubsection{Verification of Environment Input Rules} % (fold)
\label{ssub:verification_of_environment_input_rules}

% subsubsection verification_of_environment_input_rules (end)

\subsubsection{Verification of Environment Access Rules} % (fold)
\label{ssub:verification_of_environment_access_rules}

% subsubsection verification_of_environment_access_rules (end)

% subsection verification_of_other_semantic_forms (end)

% section the_core_algorithms (end)

\section{Special Language Features} % (fold)
\label{sec:special_language_features}
% Talk about the design of each of the language features, and prove the required termination properties here.
% Talk about those that were considered but not designed and WHY

\subsection{Feature --- \texttt{base}} % (fold)
\label{sub:feature_base}
% Needs some utility functions for assesing length of productions (e.g. number of items in a syntax list)
% Utility special syntax for environment gets (for use in normal syntactic rules).
% Storing and retrieval of constant keys (a design issue with the grammar)

% subsection feature_base (end)

\subsection{Feature --- \texttt{number}} % (fold)
\label{sub:feature_number}

% subsection feature_number (end)

\subsection{Feature --- \texttt{string}} % (fold)
\label{sub:feature_string}

% subsection feature_string (end)

\subsection{Feature --- \texttt{list}} % (fold)
\label{sub:feature_list}

% subsection feature_list (end)

\subsection{Feature --- \texttt{matrix}} % (fold)
\label{sub:feature_matrix}

% subsection feature_matrix (end)

\subsection{Feature --- \texttt{traverse}} % (fold)
\label{sub:feature_traverse}

% subsection feature_traverse (end)

\subsection{Feature --- \texttt{funcall}} % (fold)
\label{sub:feature_funcall}

% subsection feature_funcall (end)

% section special_language_features (end)

% chapter architecture_and_algorithms (end)
