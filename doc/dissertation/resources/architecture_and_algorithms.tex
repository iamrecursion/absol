% How the problem is analysed to create the solution.
% Overall architecture of the design.
% Examine the design approaches taken.
% Identification of areas of the design that account for the requirements and resolve potential conflicts. 
% 

\chapter{Architecture and Algorithms} % (fold)
\label{cha:architecture_and_algorithms}
% This section will contain:
% \begin{itemize}
%     \item \textbf{Architectural Overview:} An overview of the system architecture, linked to the high-level requirements.
%     This will touch on the portions of the system that were ruled out of scope later on, and why.
%     \item \textbf{System Component Examination:} An examination of the design of each of the system components in detail.
%     \item \textbf{The Development of Metaspec:} The process of developing the metaspec language itself, as well as some syntax examples and full syntax description. 
%     \item \textbf{Algorithmic Descriptions:} The verification engine in particular is very heavy on algorithmic work. 
%     These algorithms will be explained here, accompanied by any additional proof work that they require. 
%     This will include proofs for the special form semantics.
%     It will also look at initial or discarded algorithmic designs as part of the process. 
% \end{itemize}

As a project, \gls{absol} has had a very heavy research bent. 
The experimental nature of the toolchain resulted in a heavy up-front design load and, combined with the highly theoretical nature of the language verification algorithms, this meant that design and algorithmic development dominated the time spent on the project.\\

This section aims to illustrate the significant design work that was put into all facets of the project.
It first explores the design process for the metalanguage, \gls{metaspec}, demonstrating the careful thought that went into the final result. 
It then provides a high-level overview of the architecture of the toolchain, showing the main system components and tying them to the overarching system requirements.
Finally, it concludes with the design of both the core algorithms and special language features that are integral to the operation of \gls{absol}. 

\section{Designing the Metalanguage --- Metaspec} % (fold)
\label{sec:designing_the_metalanguage_metaspec}
% Careful consideration of why each bit of syntax looks like it does, what it allows the user to do. 
% Design for intuition and flexibility.
% Look like the source kind of semantics -> provide examples. 
% Consideration of where the semantics needed to be placed in the syntax for it to make real sense. 

\gls{metaspec} is the metalanguage for the \gls{absol} project, allowing the language designers to specify both the syntax and semantics of their DSL, as well as associated metadata, in a unified form. 
The final syntax for Metaspec is the result of significant design work, and consequentially the syntax discussed below has been through some evolution. \\

Metaspec is, in itself, a \gls{dsl}, and hence its design process was an interesting insight into how people might use the language to design their own \glspl{dsl}. \\

The complete grammar for Metaspec can be found in Appendix~\ref{cha:the_metaspec_grammar}, and is written in standard \gls{ebnf} notation. 
The same notation will be used throughout this section of the document. 

\subsection{The Top-Level Definitions} % (fold)
\label{sub:the_top_level_definitions}
The top-level structure of a Metaspec file consists of a series of ordered top-level definitions.
The presence of these definitions emerged from the seemingly disparate nature of a number of the requirements placed upon the language.
They are as follows:
\begin{enumerate}
    \item The language name (Requirement~\reqref{req:LanguageMetadata})
    \item The language version (Requirement~\reqref{req:LanguageMetadata})
    \item Language feature imports (Requirement~\reqref{req:ExtensionMechanisms})
    \item Ground truths for the proof engine (Requirement~\reqref{req:Ground-TruthSemantics})
    \item The language itself (Requirement~\reqref{req:IntegratedSyntaxandSemanticSpecification})
\end{enumerate}

Tying these somewhat disparate areas together is the requirement for language definition files to read in an ``intuitive'' fashion (Requirement~\reqref{req:IntuitiveFileStructure}). 
This provided an initial sense for the ordering of the language definitions, as each block assisted in providing the contextual foundation for the language definition itself. \\

To this end, the decision was made to enforce the ordering of these in the language grammar itself (as seen in Listing~\ref{lst:top_level_metaspec_definition_blocks}, with the ordering as above.
\begin{lstlisting}[caption={Top-Level Metaspec Definition Blocks}, label={lst:top_level_metaspec_definition_blocks}, firstnumber=156]
metaspec-defblock = 
    name-defblock, rule-termination-symbol, 
    version-defblock, rule-termination-symbol, 
    using-defblock, rule-termination-symbol, 
    truths-defblock, rule-termination-symbol, 
    language-defblock, rule-termination-symbol;
\end{lstlisting}

Placing the metadata fields first was a natural way to provide some initial context as to the language and version, and also assists with at-a-glance determining the language version in a \gls{vcs}.
As the extensions import list, the \lstinline{using-defblock}, can contain dependencies of the other two blocks, it made a significant amount of sense to put this next, as it aids in establishing context for the next two blocks.\\

The ordering of the termination truths (\lstinline{truths-defblock}) and the language definition itself (\lstinline{language-defblock}) was similarly natural. 
While the truths are mainly depended upon by the termination proof mechanism (see Section~\ref{sub:the_verification_engine}), they can also act as a guide to the language designer to indicate where they will be required to provide semantics for a language production. 
This quite clearly indicates that the termination truths should come before the language definition itself, as they provide additional context for the language designer.\\

While one might argue for the separation of these top-level elements, particularly the metadata, into multiple files, it seems far more natural to combine them all under one umbrella.
This means that each language definition is a self-contained unit with all the context required to understand it. 
While this single-file requirement does mean that definitions for large DSl

Each of these top-level blocks have fairly distinct forms, and each was designed very carefully to aid the language designer's understanding of the file.

\subsubsection{The Metadata Blocks} % (fold)
\label{ssub:the_metadata_blocks}
These two blocks, defining the language name and language version are almost trivial to define. 
However, care was taken not to enforce any particular naming or version scheme on the users of Metaspec.
\citet{raemaekers2014semantic} found that the semantics of a version string vary dramatically among software projects, and so it made little sense to impose a particular scheme in this case. \\

To this end, both the name and version strings for the language consist of a string of utf-8 characters.
They are parsed from the first non-whitespace character to the last that occurs before the rule termination symbol (\lstinline{;}), as seen in Listing~\ref{lst:metadata_block_definitions}.
This ensures the maximum flexibility for the users of Metaspec. 

\begin{lstlisting}[numbers=none, caption={Metadata Block Definitions}, label={lst:metadata_block_definitions}]
name-defblock = "name", where-symbol, { utf-8-char }-,;
version-defblock = "version", where-symbol, { utf-8-char }-,;
\end{lstlisting}

% subsubsection the_metadata_blocks (end)

\subsubsection{The Imports Definition Block} % (fold)
\label{ssub:the_imports_definition_block}
In defining the style of imports for the language extension features (Requirement~\reqref{req:ExtensionMechanisms}) there were two main forms considered for use in Metaspec.\\

The first style of import declaration that was considered was what the project terms the `one-line-per-import' style. 
This is seen in myriad programming languages, and has each import as a single statement. 
This does feature benefits for user parsing, as well as complicated import statements possibly being easier to read. 
Such a style can be seen in \autoref{lst:haskell_import_style} below.

\begin{listing}
\begin{minted}[numbers=none]{haskell}
import qualified Data.Map                     as M
import           Data.Maybe                   (fromJust, isJust)
import qualified Data.Set                     as S
\end{minted}
\caption{Haskell Import Style}
\label{lst:haskell_import_style}
\end{listing}

% subsubsection the_imports_definition_block (end)

\subsubsection{Comments in Metaspec} % (fold)
\label{ssub:comments_in_metaspec}
During the consideration of the high-level structure of the metalanguage, it was important to determine the appearance of comments in the language.
Comments are crucial in any programming or specification language, and hence had to be included in Metaspec. \\

Requirement~\reqref{req:Comments} states that these comments need not have any semantic meaning in the language (contrasted with Python Docstrings, which are compiled with their functions \citep{python_docstrings}).
This meant that the commenting syntax could be very simple, allowing the parser to strip them directly, rather than be parsed.
To this end, it is stated in the language specification that all comments are removed in a preprocessing step. \\

Comments themselves are defined as follows, and both a line comment and block comment style are provided:
\begin{lstlisting}[caption={Comments in Metaspec}, label={lst:comments_in_metaspec}, firstnumber=149]
metaspec-comment =
    line-comment-start-symbol, { utf-8-char }, eol-symbol |
    block-comment-start-symbol, { utf-8-char }, block-comment-end-symbol;
\end{lstlisting}

The choice of \lstinline{line-comment-start-symbol}, \lstinline{block-comment-start-symbol} and \lstinline{block-comment-end-symbol} was effectively arbitrary.
The block comment style was taken directly from \gls{ebnf}, as specified in \cite{standard1996ebnf}, but there was no line comment style to go on as EBNF does not provide one. \\

While block comments can be used on a single line they contribute additional visual noise with their end-delimiter, and hence it seemed appropriate to include a line-comment style as well.
With no prior reference to go on, the C-style line comment operator was chosen as it has been adopted my many programming languages. \\

As a result, the comment symbols are defined in Metaspec as follows.
\begin{lstlisting}[caption={Metaspec Comment Symbols}, label={lst:metaspec_comment_symbols}, numbers=none]
line-comment-start-symbol = "//";
block-comment-start-symbol = "(*";
block-comment-end-symbol = "*)";
\end{lstlisting}

% subsubsection comments_in_metaspec (end)

% subsection the_top_level_definitions (end)

\subsection{Specifying the Language Syntax} % (fold)
\label{sub:specifying_the_language_syntax}
% Why were the changes from EBNF made? 
% Removal of empty syntax

% subsection specifying_the_language_syntax (end)

\subsection{Specifying the Language Semantics} % (fold)
\label{sub:specifying_the_language_semantics}
% Semantics and the unspecified cases. 

% subsection specifying_the_language_semantics (end)

\subsection{Combining Syntax and Semantics} % (fold)
\label{sub:combining_syntax_and_semantics}
% Challenges choosing the combination point
% Initially at the production level, but this was nonsensical
% What does having it at the alternation level allow users to do?
% Why the particular form was chosen: --> {};

% subsection combining_syntax_and_semantics (end)

% section designing_the_metalanguage_metaspec (end)

\section{Designing the Metacompiler --- ABSOL} % (fold)
\label{sec:designing_the_metacompiler_absol}
% TODO Parser: Lexer, Parser, Etc.
% TODO Verifier: Different Verification Modules, talk about the recursive nature. Preprocessor.
% Use this same style of architectural overview in the development section. 
% Architectural overview focuses on system components, not code-level components.
% Suitability of a pipeline-style architecture for the system as a whole. 

As for any large system, it is important to be able to visualise the way in which the individual system components interact and are integrated. \\

\gls{absol}, the metacompiler system 

\subsection{Lexing and Parsing} % (fold)
\label{sub:lexing_and_parsing}
% Talk about the design for the lexer and parser, informed by the use of Megaparsec.
% Talk about the process and use of datatypes to represent a very strongly typed AST

% subsection lexing_and_parsing (end)

\subsection{The Verification Engine} % (fold)
\label{sub:the_verification_engine}
% Talk about the different modules, the verification preprocessor, the recursive nature of the algorithm for traversing the metaspec AST.

% subsection the_verification_engine (end)

% section designing_the_metacompiler_absol (end)

\section{The Core Algorithms} % (fold)
\label{sec:the_core_algorithms}
% Talk about the design of each of the core algorithms in detail.

\subsection{Verifier Traversal} % (fold)
\label{sub:verifier_traversal}

% subsection verifier_traversal (end)

\subsection{Semantic Form Verification} % (fold)
\label{sub:semantic_form_verification}
% All three criteria (evals, subterms, etc)

% subsection semantic_form_verification (end)

\subsection{Guard Checking} % (fold)
\label{sub:guard_checking}

% subsection guard_checking (end)

% section the_core_algorithms (end)

\section{Special Language Features} % (fold)
\label{sec:special_language_features}
% Talk about the design of each of the language features, and prove the required termination properties here.

\subsection{Feature --- \texttt{base}} % (fold)
\label{sub:feature_base}

% subsection feature_base (end)

\subsection{Feature --- \texttt{number}} % (fold)
\label{sub:feature_number}

% subsection feature_number (end)

\subsection{Feature --- \texttt{string}} % (fold)
\label{sub:feature_string}

% subsection feature_string (end)

\subsection{Feature --- \texttt{list}} % (fold)
\label{sub:feature_list}

% subsection feature_list (end)

\subsection{Feature --- \texttt{matrix}} % (fold)
\label{sub:feature_matrix}

% subsection feature_matrix (end)

\subsection{Feature --- \texttt{traverse}} % (fold)
\label{sub:feature_traverse}

% subsection feature_traverse (end)

\subsection{Feature --- \texttt{funcall}} % (fold)
\label{sub:feature_funcall}

% subsection feature_funcall (end)

% section special_language_features (end)

% chapter architecture_and_algorithms (end)
