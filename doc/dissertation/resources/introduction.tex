\chapter{Introduction} % (fold)
\label{cha:introduction}
Modern software systems are seeing significant increases in complexity, with everything from flight computers to business software becoming harder to develop and reason about \citep{dvorak2009nasa}.
As these systems grow, domain-specific logic becomes integrated throughout their code, leading to increased levels of coupling and more potential for bugs.
With it, such a high level of coupling brings an increased risk that changes to the software cause modes of incorrect operation \citep{khawar2001developing}.\\

In a world where domain-logic is crucial to many large software systems, there has been a ``significant uptick in interest'' in the use of \glspl{dsl} \citep{fowler2010domain}.
A \gls{dsl} is a limited, application-specific language that is integrated with another software system.
The intent is thus to encode the domain rules and logic in a fashion extending beyond the syntactic constraints of the host language, represented using domain constructs and terminology \citep{Mernik:2005:DDL:1118890.1118892}.
Through the use of a \gls{dsl}, a software system is able to avoid the aforementioned dispersion, centralising this domain logic using a common syntax, and making this domain logic easier to both change and verify.\\

However, with this increasing centralisation of such core logic comes a risk: if that logic is wrong, then the entire system is going to act incorrectly.
So what if it were possible to ensure that the \gls{dsl} was correct?
What if it were possible to guarantee that it would always terminate, and always compute the right result?
\textit{This} is the inspiration for this project, this is the reason behind \gls{absol}: providing a toolchain, including a \gls{metalanguage}, \gls{metacompiler} and verification framework for the creation and formal verification of embedded, executable Domain-Specific Languages.

\section{A Problem Worth Studying} % (fold)
\label{sec:a_problem_worth_studying}
\glspl{dsl} are used throughout many industries, and they can bring major benefits in industries where safety is most critical.
However, it is in these very industries that they cause major problems should they go wrong.\\

During time spent at a financial technology company one team was observed to be using the \gls{gpl} OCaml for the specification of logic at runtime. 
With the vastly greater than necessary expressive power offered by this language, the potential for bugs was significantly increased \citep{subramanyam2003empirical}.
What if it were possible to design a capable \gls{dsl} that could be formally verified to replace the use of OCaml.
It would both be a \textit{much} better fit to the domain \textit{and} reduce the potential for bugs.\\

It is this kind of safety-critical system with which this project is concerned.
The ability to provide a method for designing and verifying \glspl{dsl} in these domains would be a boon for the safety of such systems and their runtime configuration behaviour.
While, in general, language verification is undecideable, this project establishes it as a manageable task through limiting the kinds of programs that these language scan represent.
While this is an onerous restriction for \gls{gpl}, but one that is acceptable for a \gls{dsl}, its imposition makes it possible to ensure that a given \gls{dsl} is correct.\\

As a result, the project aimed to produce two main novel contributions to the state of the art of language verification:
\begin{itemize}
    \item \textbf{A Metalanguage:} An language for the specification of both the \gls{syntax} and \gls{semantics} of the \gls{dsl}. 
    It would allow the representation of restricted forms of semantics to ensure that it is possible to prove the language correct.
    As a result, the language specification could then be verified before being used to generate a \gls{dsl} compiler. 
    \item \textbf{A Metacompiler:} A Haskell-based program that aims to generate a compiler, analysing the input language specification for correctness along the way.
    This would ensure that no bugs can be introduced in the \gls{dsl} compiler implementation as it is generated directly from specification.
\end{itemize}

While \gls{absol} never quite achieved the code-generation for the \gls{dsl} compiler, having ruled that feature as out of the project scope, it provides both the metalanguage and verification engine as robust contributions to the state of the art. 

% section a_problem_worth_studying (end)

\section{Conceptualising ABSOL} % (fold)
\label{sec:conceptualising_absol}
The entire toolchain developed by this project is known as \acrshort{absol}, the \acrlong{absol}. 
This term encompasses both the metalanguage and the metacompiler, though is often used to refer to the metacompiler directly.\\

The initial concept for the system was to have a metalanguage for the specification of these \glspl{dsl}, and then have a software program (the metacompiler) that would be capable of processing this specification.
At first, the notion of `processing' encompassed the parsing of the input file, its verification and then the generation of a \gls{dsl} compiler from that verified specification. 
This was a mammoth task, and it swiftly became apparent that while the above stages would be the ideal end result, the project time-frame would not allow for it.\\

Over time, \gls{absol} and its components underwent significant and rigorous design work, further solidifying the roles of each of the parts of the toolchain.
It was through this development that the metalanguage became \gls{metaspec}, and evolved a robust feature-set for the designing of \glspl{dsl}.
This same process resulted in the Metaparse and Metaverify modules of the metacompiler, performing language parsing and specification verification respectively.
At the same time, however, this also led to the generation of the \gls{dsl} compiler being pushed out of the project scope.

% section conceptualising_absol (end)

\section{Outlining the Dissertation} % (fold)
\label{sec:outlining_the_dissertation}
This document aims to provide a comprehensive overview of the design and development of \gls{absol}. 
\begin{itemize}
    \item It will start by providing an in-depth examination of the required background material in the form of the \nameref{cha:literature_and_technology_survey}, giving the reader a firm grounding in the theory required to understand the project as a whole.
    \item Following from the \nameref{cha:literature_and_technology_survey}, the document will examine the context in which the project exists, drawing conclusions and forming project requirements as part of the \nameref{cha:elucidation}.
    \item With the requirements for \gls{absol} firmly established, the document will go on to explore the process by which \gls{metaspec}, the metalanguage, came to exist in \nameref{cha:designing_the_metalanguage}.
    \item With the metalanguage, a precursor to designing the toolchain itself, now established, the following chapter will examine the design of the metacompiler and the algorithms underlying the verification in detail.
    This is \nameref{cha:architecture_and_algorithms}.
    \item Having provided the reader with a comprehensive overview of the design work of the project, the next chapter proceeds to detail the \nameref{cha:implementation} of the metacompiler toolchain.
    \item Implementation complete, the document discusses the \nameref{cha:testing} process applied to the software, highlighting key results and demonstrating an application of the toolchain via an example \gls{dsl}.
    \item Finally, the document concludes with an \nameref{cha:evaluation} of the project as a whole, highlighting the contributions to the state of the art as well as discussing the major successes and deficiencies of the project.
\end{itemize}

% TBC on formality here
This provides but a brief overview of what the reader has in store over the course of this document, so the best thing is to dive right in.
Please, don't forget to enjoy yourself!

% section outlining_the_dissertation (end)

% chapter introduction (end)
