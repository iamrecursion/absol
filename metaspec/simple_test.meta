// Need to update grammar to reflect the above
name : simple_test;

version : 0.0.1a;

using : {
    number,
    base,
    traverse
};

// These don't need to look like this. All of the special feature terminations
// can be taken as given but still need to be manually written -> users may want
// to specify their own semantics.
truths : {
    {integer n <= <integer>},
    // {floating n <= <floating>},
    {number n <= <number>}
};

language : {

<<simple_test>> ::= <statement> | <a> ;

<statement> ::= <my-number> | <number> | <arith-expr> | <test> | <assignment> ;

<my-number> ::= <integer> ;

<arith-expr> ::= <my-number> | <arith-op> ;

// I wish there was a way to reject these
<a> ::= <b> ;
<b> ::= <a> ;
<foo> ::= "aaA";
<bar> ::= <bar> "aa" --> { any n : {n = n1}() : {any n1 <= <bar>[0]}} ;

<arith-op> ::= 
//     <arith-expr> "+" <arith-expr> --> {
//         number n : {n = n1 + n2}() :
//             {number n1 <= <arith-expr>[0]}, {number n2 <= <arith-expr>[1]}
//     } |
//     <arith-expr> "-" <arith-expr> --> {
//         number n : {n = n1 - n2}() :
//             {number n1 <= <arith-expr>[0]}, {number n2 <= <arith-expr>[1]}
//     } |
//     <arith-expr> "*" <arith-expr> --> {
//         number n : {n = n1 * n2}() :
//             {number n1 <= <arith-expr>[0]}, {number n2 <= <arith-expr>[1]}
//     } |
//     <arith-expr> "/" <arith-expr> --> {
//         number n : {n = n1 / n2}() :
//             {number n1 <= <arith-expr>[0]}, {number n2 <= <arith-expr>[1]}
//     } |
    <arith-expr> "^" <arith-expr> <foo> --> {
        // number n : {n = 1}(n1 == 1) :
        //     {number n1 <= <arith-expr>[0]}, {number n2 <= <arith-expr>[1]} |
        number n : {n = n1 * n1}(n2 == 2) :
            {number n1 <= <arith-expr>[0]}, {number n2 <= <arith-expr>[1]} |
        // number n : {n = n1 ^ n2}(n2 < 2, n2 > 2) :
        //     {number n1 <= <arith-expr>[0]}, {number n2 <= <arith-expr>[1]} |
        number n : {n = n1 ^ n3, n3 = n2 ^ 1}() :
            {number n1 <= <arith-expr>[0]}, {number n2 <= <arith-expr>[1]}
    };

// <identifier> ::= <nondigit> { <integer> | <nondigit> };

// Defaults to returning the assigned value unless suppressed with 'none'
<assignment> ::= <statement> "=" <arith-expr> --> {
    none e <-- <statement>[0] : <arith-expr>[0]
};

<test> ::= <statement> "boo" <statement> --> {
    any map(<statement>[0], <statement>[1])
};

};
