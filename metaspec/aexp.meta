(*
Comments use the EBNF syntax, and all lines are terminated with a semicolon.
They can also use C-style line-comment syntax. 
*)

(*
- This dictates the name of the language.
- The name is parsed from the first non-whitespace token to the semicolon
*)
name : aexp;

(*
The version string is parsed from the first {non-whitespace} token after the 
colon to the semicolon.
*)
version : 0.0.1;

(*
These are the provided features that the language depends on. Specifying these 
introduces reserved words into the language. These reserved words may NOT 
correspond to the name of the feature.
*)
using : {
    funcall,
    floating-point, (* defined to mean IEEE-745 double-precision floats *)
    array,
    nondigit
};

(*
These are the things guaranteed to terminate for this language. They are 
specified as semantic blocks.
*)
truths : {
    {int n <= <integer>}, // Think about exactly what should be done here
    {string n <= <string>} // Add some more syntax to the grammar
};

(* A definition of the language syntax and semantics. *)
language : {

(* 
Double angle brackets used to indicate the start symbol. 
This expression is not well-typed...
*)
<<aexp>> ::= <function-definition> | <statement> ;

(* These defined for reference only. *)
<digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
<natural> ::= <digit> { <digit> };
<floating-point> ::= [ "+" | "-" ] <natural> [ "." <natural> ];
<nondigit> ::= <utf-8> - <digit>;

<number> ::= <floating-point>;

(*
using-types is a macro-like expression that expands to the set of types 
introduced by the 'using' directive.
*)
<type-specifier> ::= <using-types>;

<identifier> ::= <nondigit> | <identifier> <nondigit> | <identifier> <digit>;

<param-decl> ::= <type-specifier> <identifier>;

<param-decl-list> ::= <param-decl> {"," <param-decl> };

// This isn't correct -> should be function-definition and function-call
<function-decl> ::= 
    <type-specifier> <identifier> "(" <param-decl-list> ")" "{" <statement> "}" 
    --> { 
        e <-- <identifier>[0] : 
            <type-specifier>[0], <param-decl-list>[0], <statement>[0]
    };

<param-list> ::= {<statement>};

<function-call> ::= <identifier> "(" <param-list> ")" ";" --> {
    any n : {n = n1}() : {
        any n1 <= funcall(
            e.<identifier>[0].<statement>[0],
            <param-list>[0],
            e.<identifier>[0].<param-decl-list>[0]
            )
    } 
};

<test-rule> ::= "-->" --> {} ;

<statement> ::= <arith-op> | <function-call> ";";

// Issues with parsing from the perspective of syntactic and semantic operations
// Need to have a reference of allowable semantic operations? 
// These rely on operations imported with the types
<arith-op> ::=
    <statement> "+" <statement> --> {
        int n : {n = n1 + n2}() : 
            {int n1 <= <statement>[0]}, {int n2 <= <statement>[1]}
    } |
    <statement> "-" <statement> --> {
        int n : {n = n1 - n2}() : 
            {int n1 <= <statement>[0]}, {int n2 <= <statement>[1]}
    } |
    <statement> "x" <statement> --> {
        int n : {n = n1 * n2}() : 
            {int n1 <= <statement>[0]}, {int n2 <= <statement>[1]}
    } |
    <statement> "/" <statement> --> {
        int n : {n = n1 / n2}() : 
            {int n1 <= <statement>[0]}, {int n2 <= <statement>[1]}
    } |
    <statement> "^" <statement> --> {
        int n : {n = n1 ^ n2}() : 
            {int n1 <= <statement>[0]}, {int n2 <= <statement>[1]}
    };

<bool> ::= ...

<condition> ::= <bool> | <function-call> ;

<ifthen> ::= 
    "if" <condition> "then" <statement> "else" <statement> --> {
        any n : {n = n2}(n1 == true) : 
            {bool n1 <= <condition>[0]}, 
            {any n2 <= <statement>[0]} |
        any n : {n = n2}(n1 == false) : 
            {bool n1 <= <condition>[0]}, 
            {any n2 <= <statement>[1]}
    };

};
